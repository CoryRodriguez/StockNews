---
phase: 01-bot-infrastructure-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/prisma/schema.prisma
  - backend/prisma/migrations/20260228000000_add_bot_tables/migration.sql
autonomous: true
requirements: [INFRA-01, INFRA-02, INFRA-03]

must_haves:
  truths:
    - "The PostgreSQL database has BotTrade, BotConfig, and BotDailyStats tables after migration"
    - "BotConfig has all threshold fields defined with sensible defaults — no schema migrations needed in later phases to add fields"
    - "BotTrade has the full lifecycle schema including exitReason and status fields — Phase 3 can begin inserting records without schema changes"
    - "BotDailyStats is keyed on a unique date string — circuit breakers and PDT guard can upsert into it in Phase 4 without schema changes"
  artifacts:
    - path: "backend/prisma/schema.prisma"
      provides: "Prisma model definitions for BotTrade, BotConfig, BotDailyStats"
      contains: "model BotTrade, model BotConfig, model BotDailyStats"
    - path: "backend/prisma/migrations/20260228000000_add_bot_tables/migration.sql"
      provides: "CREATE TABLE statements for all three bot tables with indexes"
      contains: "CREATE TABLE"
  key_links:
    - from: "backend/prisma/schema.prisma"
      to: "backend/prisma/migrations/20260228000000_add_bot_tables/migration.sql"
      via: "migration must match schema exactly"
      pattern: "BotTrade|BotConfig|BotDailyStats"
---

<objective>
Add three Prisma models (BotTrade, BotConfig, BotDailyStats) to the schema and create the corresponding SQL migration file. No application code changes — pure persistence layer.

Purpose: All subsequent Phase 1 work (botController.ts, REST routes) depends on these Prisma client types being generated. Defining the full schema now avoids costly migrations in Phases 2–6.
Output: Updated schema.prisma with 3 new models, plus a timestamped migration SQL file ready for `prisma migrate deploy` on the VPS.
</objective>

<execution_context>
@C:/Users/Owner/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Owner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/01-bot-infrastructure-foundation/01-RESEARCH.md
@backend/prisma/schema.prisma
@backend/prisma/migrations/20260227000000_add_news_articles/migration.sql

<interfaces>
<!-- Key types the executor needs to know -->

From backend/src/config.ts:
```typescript
export const config = {
  alpacaPaperUrl: "https://paper-api.alpaca.markets",
  alpacaApiKey: process.env.ALPACA_API_KEY ?? "",
  alpacaApiSecret: process.env.ALPACA_API_SECRET ?? "",
  // ... rest of config
} as const;
```

Existing schema patterns (from backend/prisma/schema.prisma):
- `String[]` arrays are supported (see Watchlist.tickers)
- `@id @default(cuid())` is the standard for most models
- `@updatedAt` is used on all mutable models
- `@@index([field])` is used for query-heavy fields
- Migration folder convention: `20YYMMDDHHMMSS_name/migration.sql`

Latest migration timestamp: `20260227000000` — use `20260228000000` to avoid collision.
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add BotTrade, BotConfig, BotDailyStats to schema.prisma</name>
  <files>backend/prisma/schema.prisma</files>
  <action>
Append three new model blocks to the END of backend/prisma/schema.prisma (after the StrategyRule model). Do NOT modify any existing models.

**BotTrade model** — full lifecycle schema, status-indexed:
```prisma
model BotTrade {
  id             String    @id @default(cuid())
  symbol         String
  entryPrice     Float?
  exitPrice      Float?
  shares         Float?
  pnl            Float?
  catalystType   String?
  catalystTier   Int?
  exitReason     String?
  status         String
  alpacaOrderId  String?
  entryAt        DateTime?
  exitAt         DateTime?
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  @@index([status])
  @@index([symbol])
  @@index([createdAt])
}
```

Valid status values (document in comment): `"open"` | `"closed"` | `"missed"`
Valid exitReason values: `"trailing_stop"` | `"hard_stop"` | `"profit_target"` | `"time_exit"` | `"force_close"` | `"reconciled_missing_on_startup"`

**BotConfig model** — singleton row, all thresholds defined upfront:
```prisma
model BotConfig {
  id                       String   @id @default("singleton")
  enabled                  Boolean  @default(false)
  state                    String   @default("stopped")
  mode                     String   @default("paper")
  positionSizeUsd          Float    @default(500)
  confidenceMultiplierHigh Float    @default(2.0)
  confidenceMultiplierMed  Float    @default(1.0)
  confidenceMultiplierLow  Float    @default(0.5)
  maxConcurrentPositions   Int      @default(3)
  dailyLossLimitUsd        Float    @default(500)
  minWinRate               Float    @default(0.5)
  hardStopLossPct          Float    @default(7.0)
  maxHoldDurationSec       Int      @default(300)
  enabledCatalystTiers     String   @default("1,2,3,4")
  maxFloatShares           Float    @default(20000000)
  maxSharePrice            Float    @default(20)
  minRelativeVolume        Float    @default(5)
  updatedAt                DateTime @updatedAt
}
```

NOTE: `enabledCatalystTiers` is stored as a comma-separated String (e.g., `"1,2,3,4"`) rather than `Int[]` to avoid Prisma array default edge cases. Callers parse with `.split(",").map(Number)`.

Valid state values: `"stopped"` | `"running"` | `"paused"`
Valid mode values: `"paper"` | `"live"`

**BotDailyStats model** — date-keyed, unique constraint:
```prisma
model BotDailyStats {
  id            String   @id @default(cuid())
  date          String
  realizedPnl   Float    @default(0)
  tradeCount    Int      @default(0)
  dayTradeCount Int      @default(0)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@unique([date])
}
```

Date format: `"YYYY-MM-DD"` in ET timezone (e.g., `"2026-02-28"`).
  </action>
  <verify>
    <automated>cd C:/Projects/StockNews/backend && grep -c "model BotTrade\|model BotConfig\|model BotDailyStats" prisma/schema.prisma</automated>
  </verify>
  <done>grep returns 3 — all three models present in schema.prisma</done>
</task>

<task type="auto">
  <name>Task 2: Create migration SQL for bot tables</name>
  <files>backend/prisma/migrations/20260228000000_add_bot_tables/migration.sql</files>
  <action>
Create the directory `backend/prisma/migrations/20260228000000_add_bot_tables/` and write `migration.sql` with the raw SQL matching the Prisma schema above.

Follow the existing migration style from `20260227000000_add_news_articles/migration.sql` exactly: plain `CREATE TABLE` statements, quoted column names, `CREATE INDEX` for indexed fields, `CREATE UNIQUE INDEX` for unique constraints.

```sql
CREATE TABLE "BotTrade" (
    "id"            TEXT NOT NULL PRIMARY KEY,
    "symbol"        TEXT NOT NULL,
    "entryPrice"    DOUBLE PRECISION,
    "exitPrice"     DOUBLE PRECISION,
    "shares"        DOUBLE PRECISION,
    "pnl"           DOUBLE PRECISION,
    "catalystType"  TEXT,
    "catalystTier"  INTEGER,
    "exitReason"    TEXT,
    "status"        TEXT NOT NULL,
    "alpacaOrderId" TEXT,
    "entryAt"       TIMESTAMP(3),
    "exitAt"        TIMESTAMP(3),
    "createdAt"     TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt"     TIMESTAMP(3) NOT NULL
);

CREATE INDEX "BotTrade_status_idx"    ON "BotTrade"("status");
CREATE INDEX "BotTrade_symbol_idx"    ON "BotTrade"("symbol");
CREATE INDEX "BotTrade_createdAt_idx" ON "BotTrade"("createdAt");

CREATE TABLE "BotConfig" (
    "id"                       TEXT NOT NULL PRIMARY KEY DEFAULT 'singleton',
    "enabled"                  BOOLEAN NOT NULL DEFAULT false,
    "state"                    TEXT NOT NULL DEFAULT 'stopped',
    "mode"                     TEXT NOT NULL DEFAULT 'paper',
    "positionSizeUsd"          DOUBLE PRECISION NOT NULL DEFAULT 500,
    "confidenceMultiplierHigh" DOUBLE PRECISION NOT NULL DEFAULT 2.0,
    "confidenceMultiplierMed"  DOUBLE PRECISION NOT NULL DEFAULT 1.0,
    "confidenceMultiplierLow"  DOUBLE PRECISION NOT NULL DEFAULT 0.5,
    "maxConcurrentPositions"   INTEGER NOT NULL DEFAULT 3,
    "dailyLossLimitUsd"        DOUBLE PRECISION NOT NULL DEFAULT 500,
    "minWinRate"               DOUBLE PRECISION NOT NULL DEFAULT 0.5,
    "hardStopLossPct"          DOUBLE PRECISION NOT NULL DEFAULT 7.0,
    "maxHoldDurationSec"       INTEGER NOT NULL DEFAULT 300,
    "enabledCatalystTiers"     TEXT NOT NULL DEFAULT '1,2,3,4',
    "maxFloatShares"           DOUBLE PRECISION NOT NULL DEFAULT 20000000,
    "maxSharePrice"            DOUBLE PRECISION NOT NULL DEFAULT 20,
    "minRelativeVolume"        DOUBLE PRECISION NOT NULL DEFAULT 5,
    "updatedAt"                TIMESTAMP(3) NOT NULL
);

CREATE TABLE "BotDailyStats" (
    "id"            TEXT NOT NULL PRIMARY KEY,
    "date"          TEXT NOT NULL,
    "realizedPnl"   DOUBLE PRECISION NOT NULL DEFAULT 0,
    "tradeCount"    INTEGER NOT NULL DEFAULT 0,
    "dayTradeCount" INTEGER NOT NULL DEFAULT 0,
    "createdAt"     TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt"     TIMESTAMP(3) NOT NULL
);

CREATE UNIQUE INDEX "BotDailyStats_date_key" ON "BotDailyStats"("date");
```

IMPORTANT: The `updatedAt` columns have no SQL DEFAULT because Prisma manages them via its client. The migration SQL must match this — do not add `DEFAULT CURRENT_TIMESTAMP` to `updatedAt` columns (Prisma will handle updates).
  </action>
  <verify>
    <automated>ls C:/Projects/StockNews/backend/prisma/migrations/20260228000000_add_bot_tables/migration.sql</automated>
  </verify>
  <done>migration.sql file exists in the correct timestamped directory</done>
</task>

<task type="auto">
  <name>Task 3: Generate Prisma client</name>
  <files>backend/node_modules/.prisma/client (generated, not source-controlled)</files>
  <action>
Run `prisma generate` to regenerate the Prisma client with the new BotTrade, BotConfig, and BotDailyStats types. This makes `prisma.botTrade`, `prisma.botConfig`, and `prisma.botDailyStats` available to TypeScript code in Plan 02.

Run from the backend directory:
```bash
cd C:/Projects/StockNews/backend && npx prisma generate
```

Do NOT run `prisma migrate deploy` here — that applies migrations to the live database and should be done as part of deployment, not during local development. The migration SQL file is authored here and will be applied on the VPS during the deployment step after Phase 1 is complete.

If `prisma generate` produces TypeScript type errors about the new models, confirm the schema is syntactically correct by running:
```bash
npx prisma validate
```
  </action>
  <verify>
    <automated>cd C:/Projects/StockNews/backend && npx prisma validate</automated>
  </verify>
  <done>`prisma validate` exits 0 with no errors — schema is syntactically valid and client types are generated</done>
</task>

</tasks>

<verification>
After all three tasks complete, confirm:
1. `grep -c "model BotTrade\|model BotConfig\|model BotDailyStats" backend/prisma/schema.prisma` returns `3`
2. `ls backend/prisma/migrations/20260228000000_add_bot_tables/migration.sql` exits 0
3. `cd backend && npx prisma validate` exits 0
4. No existing models (User, Watchlist, Layout, PaperTrade, etc.) were modified
</verification>

<success_criteria>
- Three new Prisma models present in schema.prisma with full field definitions matching CONTEXT.md decisions
- Migration SQL file exists at the correct path with CREATE TABLE statements for all three tables
- `prisma validate` passes — schema is syntactically correct
- Prisma client regenerated with new model types available for Plan 02
- enabledCatalystTiers stored as comma-separated String (not Int[]) per research recommendation
</success_criteria>

<output>
After completion, create `.planning/phases/01-bot-infrastructure-foundation/01-01-SUMMARY.md` with:
- What was built (3 models, migration SQL)
- Key design decisions (enabledCatalystTiers as String, singleton BotConfig id, status/exitReason string values)
- Schema field names (exact camelCase as written — Plan 02 will import these Prisma types)
</output>
