---
phase: 01-bot-infrastructure-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - backend/src/services/botController.ts
  - backend/src/config.ts
autonomous: true
requirements: [INFRA-04, INFRA-05, INFRA-07, INFRA-08]

must_haves:
  truths:
    - "On server start, initBot() loads BotConfig from DB (creating the singleton row if it doesn't exist) and restores the last known bot state"
    - "On server start, reconcilePositions() fetches GET /v2/positions from the mode-appropriate Alpaca URL and marks any DB-open positions not found in the broker response as status=missed"
    - "The bot's mode (paper/live) is read from BotConfig — a single getAlpacaBaseUrl() function returns the correct URL and all Alpaca calls use it"
    - "switchMode(newMode) rejects with an error when any BotTrade has status=open — the guard is enforced at the service layer, not just the route layer"
    - "getBotState() and getBotConfig() are exported synchronous accessors that Phase 2 signal evaluation code will call without async overhead"
  artifacts:
    - path: "backend/src/services/botController.ts"
      provides: "Bot singleton: state machine, config loading, reconciliation, mode switching"
      exports: ["initBot", "getBotState", "getBotConfig", "setBotState", "switchMode", "getAlpacaBaseUrl", "persistState"]
    - path: "backend/src/config.ts"
      provides: "alpacaLiveUrl added to config object"
      contains: "alpacaLiveUrl"
  key_links:
    - from: "backend/src/services/botController.ts"
      to: "backend/prisma/schema.prisma"
      via: "prisma.botConfig.upsert with id='singleton'"
      pattern: "prisma\\.botConfig\\.upsert"
    - from: "reconcilePositions"
      to: "Alpaca GET /v2/positions"
      via: "fetch(getAlpacaBaseUrl() + '/v2/positions')"
      pattern: "getAlpacaBaseUrl.*v2/positions"
    - from: "switchMode"
      to: "prisma.botTrade.count"
      via: "count({ where: { status: 'open' } }) before accepting mode change"
      pattern: "botTrade\\.count.*open"
---

<objective>
Create backend/src/services/botController.ts — the singleton bot controller implementing the state machine, config persistence, startup reconciliation, and mode-switching guard. Also add alpacaLiveUrl to config.ts.

Purpose: This is the central brain of the bot. All subsequent phases (signal engine, executor, risk manager) call into botController to read state and config. Getting the module interface right here avoids refactors later.
Output: botController.ts with 7+ exported functions, config.ts with alpacaLiveUrl added.
</objective>

<execution_context>
@C:/Users/Owner/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Owner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/01-bot-infrastructure-foundation/01-RESEARCH.md
@.planning/phases/01-bot-infrastructure-foundation/01-01-SUMMARY.md
@backend/src/config.ts
@backend/src/services/strategyEngine.ts
@backend/src/services/paperTrader.ts

<interfaces>
<!-- Existing codebase contracts the executor needs -->

From backend/src/config.ts (current):
```typescript
export const config = {
  alpacaApiKey: process.env.ALPACA_API_KEY ?? "",
  alpacaApiSecret: process.env.ALPACA_API_SECRET ?? "",
  alpacaPaperUrl: "https://paper-api.alpaca.markets",
  // alpacaLiveUrl missing — must add it
} as const;
```

From backend/src/db/client.ts (standard Prisma client import):
```typescript
import prisma from "../db/client";
// prisma.botConfig.upsert(...)
// prisma.botTrade.findMany(...)
// prisma.botTrade.count(...)
// prisma.botTrade.update(...)
```

BotConfig Prisma model (from Plan 01 schema):
```typescript
// All fields with their defaults:
// id: "singleton" (fixed)
// enabled: false
// state: "stopped"         // "stopped" | "running" | "paused"
// mode: "paper"            // "paper" | "live"
// positionSizeUsd: 500
// confidenceMultiplierHigh: 2.0
// confidenceMultiplierMed: 1.0
// confidenceMultiplierLow: 0.5
// maxConcurrentPositions: 3
// dailyLossLimitUsd: 500
// minWinRate: 0.5
// hardStopLossPct: 7.0
// maxHoldDurationSec: 300
// enabledCatalystTiers: "1,2,3,4"  (comma-separated string)
// maxFloatShares: 20000000
// maxSharePrice: 20
// minRelativeVolume: 5
// updatedAt: DateTime (auto-managed)
```

BotTrade Prisma model fields relevant to Plan 02:
```typescript
// status: "open" | "closed" | "missed"
// exitReason: string | null
// symbol: string
```

From strategyEngine.ts (module-level singleton pattern to follow):
```typescript
// Module-level state (never exported directly)
let botState: BotState = 'stopped';
let botConfig: BotConfigRecord | null = null;

// Single init function awaited in server.listen callback
export async function initBot(): Promise<void> { ... }

// Synchronous accessors
export function getBotState(): BotState { return botState; }
export function getBotConfig(): BotConfigRecord { return botConfig!; }
```

Alpaca position response shape (from paperTrader.ts usage pattern):
```typescript
interface AlpacaPosition {
  symbol: string;
  qty: string;              // number as string
  avg_entry_price: string;  // number as string
  current_price: string;    // number as string
  unrealized_pl: string;    // number as string
  side: "long" | "short";
}
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add alpacaLiveUrl to config.ts</name>
  <files>backend/src/config.ts</files>
  <action>
Add `alpacaLiveUrl: "https://api.alpaca.markets"` to the config object in `backend/src/config.ts`, immediately after the existing `alpacaPaperUrl` line. This is the only change to config.ts — do NOT remove or modify any existing fields.

The config object should look like:
```typescript
  alpacaPaperUrl: "https://paper-api.alpaca.markets",
  alpacaLiveUrl: "https://api.alpaca.markets",
```

This enables Phase 6 (live trading mode unlock) to switch URLs via BotConfig.mode with zero code changes.
  </action>
  <verify>
    <automated>grep "alpacaLiveUrl" C:/Projects/StockNews/backend/src/config.ts</automated>
  </verify>
  <done>grep finds `alpacaLiveUrl: "https://api.alpaca.markets"` in config.ts</done>
</task>

<task type="auto">
  <name>Task 2: Create botController.ts singleton service</name>
  <files>backend/src/services/botController.ts</files>
  <action>
Create `backend/src/services/botController.ts` as a new file. Follow the module-level singleton pattern used by `strategyEngine.ts` and `scanner.ts` — module-level `let` variables, exported init function, exported synchronous accessors.

**Type definitions at top of file:**
```typescript
export type BotState = 'stopped' | 'running' | 'paused';
export type BotMode = 'paper' | 'live';

export interface BotConfigRecord {
  id: string;
  enabled: boolean;
  state: string;
  mode: string;
  positionSizeUsd: number;
  confidenceMultiplierHigh: number;
  confidenceMultiplierMed: number;
  confidenceMultiplierLow: number;
  maxConcurrentPositions: number;
  dailyLossLimitUsd: number;
  minWinRate: number;
  hardStopLossPct: number;
  maxHoldDurationSec: number;
  enabledCatalystTiers: string;  // comma-separated "1,2,3,4"
  maxFloatShares: number;
  maxSharePrice: number;
  minRelativeVolume: number;
  updatedAt: Date;
}
```

**Module-level state (private, not exported):**
```typescript
let botState: BotState = 'stopped';
let botConfig: BotConfigRecord | null = null;
```

**Alpaca headers helper (private):**
```typescript
function getAlpacaHeaders() {
  return {
    'APCA-API-Key-ID': config.alpacaApiKey,
    'APCA-API-Secret-Key': config.alpacaApiSecret,
  };
}
```

**`getAlpacaBaseUrl()` (exported) — mode-aware URL selector:**
```typescript
export function getAlpacaBaseUrl(): string {
  if (!botConfig) return config.alpacaPaperUrl;
  return botConfig.mode === 'live' ? config.alpacaLiveUrl : config.alpacaPaperUrl;
}
```

**`isMarketOpen()` helper (exported) — simple ET time check, no holiday support:**
```typescript
export function isMarketOpen(): boolean {
  const now = new Date();
  const etTime = new Date(now.toLocaleString('en-US', { timeZone: 'America/New_York' }));
  const day = etTime.getDay(); // 0=Sun, 6=Sat
  if (day === 0 || day === 6) return false;
  const totalMinutes = etTime.getHours() * 60 + etTime.getMinutes();
  return totalMinutes >= 9 * 60 + 30 && totalMinutes < 16 * 60;
}
```

**`getTodayDateET()` helper (private) — for BotDailyStats upserts:**
```typescript
function getTodayDateET(): string {
  return new Date().toLocaleDateString('en-US', {
    timeZone: 'America/New_York',
    year: 'numeric',
    month: '2-digit',
    day: '2-digit',
  }).split('/').reverse().join('-').replace(/(\d{4})-(\d{2})-(\d{2})/, '$1-$3-$2');
  // Returns "YYYY-MM-DD"
}
```

NOTE: A simpler approach is:
```typescript
function getTodayDateET(): string {
  return new Intl.DateTimeFormat('en-CA', { timeZone: 'America/New_York' }).format(new Date());
  // en-CA locale formats as YYYY-MM-DD natively
}
```
Use whichever is cleaner and produces correct YYYY-MM-DD output.

**`reconcilePositions()` (private async) — startup reconciliation:**
```typescript
async function reconcilePositions(): Promise<void> {
  try {
    const res = await fetch(`${getAlpacaBaseUrl()}/v2/positions`, {
      headers: getAlpacaHeaders(),
    });
    const livePositions: Array<{ symbol: string }> = res.ok ? await res.json() : [];
    const liveSymbols = new Set(livePositions.map((p) => p.symbol));

    const dbOpenTrades = await prisma.botTrade.findMany({
      where: { status: 'open' },
    });

    let reconciled = 0;
    for (const trade of dbOpenTrades) {
      if (!liveSymbols.has(trade.symbol)) {
        await prisma.botTrade.update({
          where: { id: trade.id },
          data: { status: 'missed', exitReason: 'reconciled_missing_on_startup' },
        });
        reconciled++;
      }
    }
    console.log(`[BotController] Reconciled ${dbOpenTrades.length} open positions, ${reconciled} marked missed`);
  } catch (err) {
    // Do NOT throw — server must start even if Alpaca is unreachable (outside market hours, bad key, etc.)
    console.warn('[BotController] reconcilePositions failed (non-fatal):', err);
  }
}
```

**`initBot()` (exported async) — called once from index.ts:**
```typescript
export async function initBot(): Promise<void> {
  // Load or create the singleton BotConfig row
  botConfig = await prisma.botConfig.upsert({
    where: { id: 'singleton' },
    update: {},  // No update on first load — preserve existing values
    create: {
      id: 'singleton',
      enabled: false,
      state: 'stopped',
      mode: 'paper',
      positionSizeUsd: 500,
      confidenceMultiplierHigh: 2.0,
      confidenceMultiplierMed: 1.0,
      confidenceMultiplierLow: 0.5,
      maxConcurrentPositions: 3,
      dailyLossLimitUsd: 500,
      minWinRate: 0.5,
      hardStopLossPct: 7.0,
      maxHoldDurationSec: 300,
      enabledCatalystTiers: '1,2,3,4',
      maxFloatShares: 20000000,
      maxSharePrice: 20,
      minRelativeVolume: 5,
    },
  });

  // Restore last known state
  botState = botConfig.state as BotState;

  console.log(`[BotController] Initialized — state=${botState}, mode=${botConfig.mode}`);

  // Reconcile open positions against broker before accepting signals
  await reconcilePositions();
}
```

**Exported synchronous accessors:**
```typescript
export function getBotState(): BotState { return botState; }
export function getBotConfig(): BotConfigRecord { return botConfig!; }
```

**`setBotState()` (exported) — updates in-memory state AND persists to DB:**
```typescript
export async function setBotState(newState: BotState): Promise<void> {
  botState = newState;
  await prisma.botConfig.update({
    where: { id: 'singleton' },
    data: { state: newState },
  });
}
```

**`switchMode()` (exported) — rejects if open positions exist:**
```typescript
export async function switchMode(newMode: BotMode): Promise<void> {
  const openCount = await prisma.botTrade.count({
    where: { status: 'open' },
  });
  if (openCount > 0) {
    throw new Error(`Cannot switch mode: ${openCount} position(s) currently open`);
  }
  botConfig = await prisma.botConfig.update({
    where: { id: 'singleton' },
    data: { mode: newMode },
  });
}
```

**`updateConfig()` (exported) — partial config updates for future Phase 5 UI:**
```typescript
export async function updateConfig(
  patch: Partial<Omit<BotConfigRecord, 'id' | 'updatedAt'>>
): Promise<BotConfigRecord> {
  botConfig = await prisma.botConfig.update({
    where: { id: 'singleton' },
    data: patch,
  });
  return botConfig;
}
```

Imports at top of file:
```typescript
import prisma from '../db/client';
import { config } from '../config';
```
  </action>
  <verify>
    <automated>cd C:/Projects/StockNews/backend && npx tsc --noEmit 2>&1 | grep -i "botController" | head -20</automated>
  </verify>
  <done>tsc --noEmit produces zero errors referencing botController.ts (warnings about other files are acceptable)</done>
</task>

</tasks>

<verification>
After both tasks:
1. `grep "alpacaLiveUrl" backend/src/config.ts` finds the live URL
2. `grep -c "export" backend/src/services/botController.ts` returns 7+ (initBot, getBotState, getBotConfig, setBotState, switchMode, getAlpacaBaseUrl, isMarketOpen, updateConfig)
3. `cd backend && npx tsc --noEmit 2>&1 | grep botController` — no errors for botController.ts
4. switchMode contains `prisma.botTrade.count` — mode guard is at service layer
5. reconcilePositions has `catch (err)` with `console.warn` and no `throw` — non-fatal on Alpaca unreachable
</verification>

<success_criteria>
- config.ts has alpacaLiveUrl (enables Phase 6 paper→live switch with no code changes — INFRA-07)
- botController.ts uses module-level singleton pattern matching strategyEngine.ts and scanner.ts
- initBot() uses prisma.botConfig.upsert with full default create block — no "missing required fields" error on first startup
- reconcilePositions() is non-fatal: catches errors, logs warning, never throws
- switchMode() counts open BotTrade rows before accepting mode switch — INFRA-08 guard at service layer
- getAlpacaBaseUrl() reads botConfig.mode to select paper vs live URL — INFRA-07 single source of truth
- All exports are TypeScript-clean (tsc --noEmit passes for botController.ts)
</success_criteria>

<output>
After completion, create `.planning/phases/01-bot-infrastructure-foundation/01-02-SUMMARY.md` with:
- Exported function signatures (Phase 3 will call setBotState; Phase 2 will call getBotState and getBotConfig)
- The BotConfigRecord interface definition (Phase 2 needs to read config fields like minWinRate)
- Key design note: enabledCatalystTiers is a comma-separated string — parse with .split(",").map(Number)
- Key design note: getBotConfig() returns non-null after initBot() is awaited in server startup
</output>
