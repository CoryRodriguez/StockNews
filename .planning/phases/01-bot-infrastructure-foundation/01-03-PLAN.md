---
phase: 01-bot-infrastructure-foundation
plan: 03
type: execute
wave: 3
depends_on: ["01-01", "01-02"]
files_modified:
  - backend/src/routes/bot.ts
  - backend/src/index.ts
autonomous: true
requirements: [INFRA-05, INFRA-06]

must_haves:
  truths:
    - "POST /api/bot/start transitions bot from stopped to running, persists the state, and returns {state: 'running'}"
    - "POST /api/bot/pause transitions bot from running to paused (no new buys, but positions continue to be monitored), persists state"
    - "POST /api/bot/resume transitions bot from paused to running, persists state"
    - "POST /api/bot/stop transitions bot from running or paused to stopped, persists state"
    - "GET /api/bot/status returns bot state, mode, openPositionCount, todayRealizedPnl, todayTradeCount, and marketOpen flag"
    - "Invalid state transitions (e.g., start when already running) return HTTP 400 with an error message"
    - "All bot endpoints require authentication (requireAuth middleware)"
    - "initBot() is awaited in the server.listen callback in index.ts, AFTER loadStrategiesFromDb()"
  artifacts:
    - path: "backend/src/routes/bot.ts"
      provides: "Express Router with /start, /pause, /resume, /stop, /status endpoints"
      exports: ["default (Router)"]
    - path: "backend/src/index.ts"
      provides: "Bot router mounted at /api/bot and initBot() called in startup sequence"
      contains: "app.use('/api/bot', botRouter)"
  key_links:
    - from: "backend/src/routes/bot.ts"
      to: "backend/src/services/botController.ts"
      via: "imports getBotState, setBotState, getBotConfig, switchMode, isMarketOpen"
      pattern: "import.*botController"
    - from: "backend/src/index.ts"
      to: "backend/src/services/botController.ts"
      via: "await initBot() in server.listen callback"
      pattern: "await initBot"
    - from: "GET /api/bot/status"
      to: "prisma.botTrade.count + prisma.botDailyStats.findFirst"
      via: "live position count and today's stats aggregation"
      pattern: "prisma\\.botTrade\\.count|botDailyStats\\.findFirst"
---

<objective>
Create backend/src/routes/bot.ts with five REST endpoints and wire it into index.ts. This is the final piece of Phase 1 — after this plan, the bot has a persistence layer, a lifecycle controller, and a REST API to drive it.

Purpose: These endpoints are the control surface for the Phase 5 UI and for manual testing of bot state during Phases 2–4 development.
Output: routes/bot.ts with 5 endpoints, index.ts updated with router mount + initBot() call.
</objective>

<execution_context>
@C:/Users/Owner/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Owner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/01-bot-infrastructure-foundation/01-RESEARCH.md
@.planning/phases/01-bot-infrastructure-foundation/01-02-SUMMARY.md
@backend/src/index.ts
@backend/src/routes/trades.ts
@backend/src/middleware/auth.ts

<interfaces>
<!-- Contracts from Plan 02 that this plan consumes -->

From backend/src/services/botController.ts (created in Plan 02):
```typescript
export type BotState = 'stopped' | 'running' | 'paused';
export type BotMode = 'paper' | 'live';

export interface BotConfigRecord {
  id: string;
  enabled: boolean;
  state: string;
  mode: string;
  positionSizeUsd: number;
  // ... all threshold fields
}

export async function initBot(): Promise<void>;
export function getBotState(): BotState;
export function getBotConfig(): BotConfigRecord;
export async function setBotState(newState: BotState): Promise<void>;
export async function switchMode(newMode: BotMode): Promise<void>;
export function getAlpacaBaseUrl(): string;
export function isMarketOpen(): boolean;
export async function updateConfig(patch: Partial<...>): Promise<BotConfigRecord>;
```

Valid state transitions:
```
stopped  → running   (POST /start)
running  → paused    (POST /pause)
running  → stopped   (POST /stop)
paused   → running   (POST /resume)
paused   → stopped   (POST /stop)
```

From backend/src/middleware/auth.ts:
```typescript
export function requireAuth(req: AuthRequest, res: Response, next: NextFunction): void;
```

From backend/src/routes/trades.ts (pattern to follow):
```typescript
import { Router } from 'express';
import prisma from '../db/client';
import { requireAuth } from '../middleware/auth';
const router = Router();
// router.get(...) / router.post(...)
export default router;
```

From backend/src/index.ts (current startup sequence):
```typescript
server.listen(config.port, async () => {
  console.log(`[Server] Listening on :${config.port}`);
  await loadArticlesFromDb();
  startRtpr();
  startBenzinga();
  startAlpacaNews();
  startAlpacaWs();
  startScanner();
  await loadStrategiesFromDb();
  await recomputeStrategies();
  setInterval(() => recomputeStrategies(), 60 * 60 * 1000);
});
```
initBot() must be added AFTER `await recomputeStrategies()`.

GET /api/bot/status response shape:
```typescript
{
  state: "stopped" | "running" | "paused",
  mode: "paper" | "live",
  openPositionCount: number,
  todayRealizedPnl: number,
  todayTradeCount: number,
  marketOpen: boolean,
}
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create routes/bot.ts with lifecycle endpoints</name>
  <files>backend/src/routes/bot.ts</files>
  <action>
Create `backend/src/routes/bot.ts`. Follow the trades.ts router pattern exactly: import Router from express, import requireAuth, export default router.

**Imports:**
```typescript
import { Router } from 'express';
import prisma from '../db/client';
import { requireAuth } from '../middleware/auth';
import {
  getBotState,
  setBotState,
  getBotConfig,
  switchMode,
  isMarketOpen,
  type BotState,
} from '../services/botController';
```

**POST /start:**
- Valid from: `stopped` only
- Transition to: `running`
- Guard: if state is already `running` → 400 `{ error: 'Bot is already running' }`
- Guard: if state is `paused` → 400 `{ error: 'Bot is paused — use /resume to continue' }`
- On success: call `await setBotState('running')`, return `{ state: 'running' }`

**POST /pause:**
- Valid from: `running` only
- Transition to: `paused`
- Guard: if not `running` → 400 `{ error: 'Bot must be running to pause' }`
- On success: call `await setBotState('paused')`, return `{ state: 'paused' }`
- Note: pause semantics from CONTEXT.md — no new buy signals, but open positions continue to be monitored (the position monitor in Phase 3 checks state !== 'stopped', not state === 'running')

**POST /resume:**
- Valid from: `paused` only
- Transition to: `running`
- Guard: if not `paused` → 400 `{ error: 'Bot must be paused to resume' }`
- On success: call `await setBotState('running')`, return `{ state: 'running' }`

**POST /stop:**
- Valid from: `running` or `paused`
- Transition to: `stopped`
- Guard: if already `stopped` → 400 `{ error: 'Bot is already stopped' }`
- On success: call `await setBotState('stopped')`, return `{ state: 'stopped' }`

**GET /status:**
- No state guard — always returns current snapshot
- Must query DB for: open position count, today's P&L, today's trade count
- Today's date in ET using `new Intl.DateTimeFormat('en-CA', { timeZone: 'America/New_York' }).format(new Date())`

```typescript
router.get('/status', requireAuth, async (_req, res) => {
  try {
    const cfg = getBotConfig();
    const todayET = new Intl.DateTimeFormat('en-CA', { timeZone: 'America/New_York' }).format(new Date());

    const [openPositionCount, dailyStats] = await Promise.all([
      prisma.botTrade.count({ where: { status: 'open' } }),
      prisma.botDailyStats.findFirst({ where: { date: todayET } }),
    ]);

    res.json({
      state: getBotState(),
      mode: cfg.mode,
      openPositionCount,
      todayRealizedPnl: dailyStats?.realizedPnl ?? 0,
      todayTradeCount: dailyStats?.tradeCount ?? 0,
      marketOpen: isMarketOpen(),
    });
  } catch (err) {
    res.status(500).json({ error: 'Failed to load bot status' });
  }
});
```

All endpoints must use `requireAuth`. Wrap all async handlers in try/catch that return 500 on unexpected errors.
  </action>
  <verify>
    <automated>cd C:/Projects/StockNews/backend && npx tsc --noEmit 2>&1 | grep -i "routes/bot" | head -10</automated>
  </verify>
  <done>tsc --noEmit produces zero errors referencing routes/bot.ts</done>
</task>

<task type="auto">
  <name>Task 2: Wire bot router and initBot() into index.ts</name>
  <files>backend/src/index.ts</files>
  <action>
Make two additions to `backend/src/index.ts`:

**Addition 1 — Import statements** (add to the existing import block, after the `analyticsRouter` import line):
```typescript
import botRouter from './routes/bot';
import { initBot } from './services/botController';
```

**Addition 2 — Router mount** (add to the Routes section, after `app.use('/api/analytics', analyticsRouter)`):
```typescript
app.use('/api/bot', botRouter);
```

**Addition 3 — initBot() in server.listen callback** (add AFTER `await recomputeStrategies()` and BEFORE the `setInterval` call):
```typescript
  // Initialize bot controller (loads config, reconciles positions)
  await initBot();
```

The final server.listen callback order must be:
1. `await loadArticlesFromDb()`
2. `startRtpr()`, `startBenzinga()`, `startAlpacaNews()`, `startAlpacaWs()`, `startScanner()`
3. `await loadStrategiesFromDb()`
4. `await recomputeStrategies()`
5. `await initBot()` ← NEW (strategy cache must be warm before bot starts)
6. `setInterval(() => recomputeStrategies(), ...)`

IMPORTANT: `initBot()` MUST be `await`ed — if called fire-and-forget, reconcilePositions() may not complete before Phase 2 signal listeners register, allowing signals against unreconciled state.
  </action>
  <verify>
    <automated>cd C:/Projects/StockNews/backend && npx tsc --noEmit 2>&1 | head -30</automated>
  </verify>
  <done>tsc --noEmit exits 0 (or shows only pre-existing errors, not new ones introduced by this plan)</done>
</task>

</tasks>

<verification>
After both tasks complete:
1. `grep "app.use('/api/bot'" backend/src/index.ts` finds the bot router mount
2. `grep "await initBot" backend/src/index.ts` finds the awaited init call
3. `grep "await recomputeStrategies" backend/src/index.ts` appears BEFORE `await initBot` — strategy cache is warm first
4. `cd backend && npx tsc --noEmit` exits with zero new errors
5. Manually review routes/bot.ts: all 5 endpoints present (/start, /pause, /resume, /stop, /status)
6. All 5 endpoints have `requireAuth` as middleware
7. GET /status response includes all 6 fields: state, mode, openPositionCount, todayRealizedPnl, todayTradeCount, marketOpen
</verification>

<success_criteria>
- Five endpoints implemented with correct state transition guards (INFRA-06)
- Invalid transitions return 400 with descriptive error messages
- GET /api/bot/status returns the full snapshot shape specified in CONTEXT.md
- initBot() is awaited in server.listen callback, positioned after strategy cache is warm (INFRA-04, INFRA-05)
- All bot endpoints require authentication (matches existing route pattern)
- TypeScript compiles cleanly — no new errors introduced
- Phase 1 complete: persistence layer (Plan 01) + controller (Plan 02) + REST API (Plan 03) are all wired together
</success_criteria>

<output>
After completion, create `.planning/phases/01-bot-infrastructure-foundation/01-03-SUMMARY.md` with:
- The 5 endpoint signatures and their state transition rules
- The GET /api/bot/status response shape
- Confirmation that initBot() is wired in index.ts startup sequence
- Any TypeScript issues encountered and how they were resolved

Then update `.planning/STATE.md`:
- Current plan: "Plan 03 complete"
- Status: "Phase 1 complete"
- Total plans created: 3
- Total plans complete: 3
</output>
