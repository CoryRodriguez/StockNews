---
phase: 02-signal-engine
plan: "02"
type: execute
wave: 2
depends_on:
  - "02-01"
files_modified:
  - backend/src/services/signalEngine.ts
autonomous: true
requirements:
  - SIG-02
  - SIG-03
  - SIG-04
  - SIG-05
  - SIG-06
  - SIG-08
  - SIG-09
  - SIG-10

must_haves:
  truths:
    - "evaluateBotSignal(article) is exported and callable from any news service file"
    - "notifyReconnect(source) is exported for RTPR and AlpacaNews to call on ws.on('open') after first connect"
    - "An article where getBotState() !== 'running' causes a silent skip — no DB write"
    - "An article with createdAt 91+ seconds before evaluation returns 'stale' as rejectReason in BotSignalLog"
    - "Two calls with identical symbol+normalizedTitle within 5 minutes: only the first writes a BotSignalLog record"
    - "During the 30 seconds after notifyReconnect('rtpr') is called, articles from source 'rtpr' log rejectReason 'reconnect-cooldown'"
    - "An article arriving between 9:30 and 9:45 AM ET logs rejectReason 'opening-auction'"
    - "An article where getSnapshots returns price > config.maxSharePrice logs rejectReason 'failed-5-pillars' and failedPillar 'price'"
    - "An article where relativeVolume < config.minRelativeVolume logs rejectReason 'failed-5-pillars' and failedPillar 'relative_volume'"
    - "A tier 1 or tier 2 article that passes all pillar checks logs outcome 'fired' and rejectReason 'log-only'"
    - "TypeScript compiles with zero errors after creating signalEngine.ts"
  artifacts:
    - path: "backend/src/services/signalEngine.ts"
      provides: "Core signal evaluation pipeline: gate sequence + 5 Pillars check + BotSignalLog write"
      exports: ["evaluateBotSignal", "notifyReconnect"]
      min_lines: 150
  key_links:
    - from: "backend/src/services/signalEngine.ts"
      to: "backend/src/services/botController.ts"
      via: "import { getBotState, getBotConfig, isMarketOpen }"
      pattern: "getBotState\\(\\)"
    - from: "backend/src/services/signalEngine.ts"
      to: "backend/src/services/catalystClassifier.ts"
      via: "import { classifyCatalystGranular }"
      pattern: "classifyCatalystGranular"
    - from: "backend/src/services/signalEngine.ts"
      to: "backend/src/services/alpaca.ts"
      via: "import { getSnapshots }"
      pattern: "getSnapshots\\("
    - from: "backend/src/services/signalEngine.ts"
      to: "backend/src/services/strategyEngine.ts"
      via: "import { getStrategy }"
      pattern: "getStrategy\\("
    - from: "backend/src/services/signalEngine.ts"
      to: "prisma.botSignalLog"
      via: "import prisma from ../db/client"
      pattern: "botSignalLog\\.create"
---

<objective>
Create signalEngine.ts with the complete 10-step evaluation gauntlet (everything except the Claude AI branch). This plan builds all guards — state, market hours, reconnect cooldown, staleness, deduplication, tier check, opening auction, win-rate, and 5 Pillars — and writes BotSignalLog for every outcome.

Purpose: The signal engine is the critical path for Phase 2 correctness. Each guard must fire in the exact sequence defined in the research so the audit log captures the first rejection reason.

Output: backend/src/services/signalEngine.ts with exported evaluateBotSignal() and notifyReconnect() functions. The file is complete for all non-AI code paths; Plan 02-03 adds the AI branch and hooks in the news services.
</objective>

<execution_context>
@C:/Users/Owner/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Owner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-signal-engine/02-RESEARCH.md

@.planning/phases/01-bot-infrastructure-foundation/01-02-SUMMARY.md
</context>

<interfaces>
<!-- Key types and contracts the executor needs. Extracted from codebase. -->

From backend/src/services/rtpr.ts:
```typescript
export interface RtprArticle {
  ticker: string;
  title: string;
  body: string;
  author: string;
  source: string;    // "rtpr" | "benzinga" | "alpaca"
  createdAt: string; // ISO string
  receivedAt: string; // ISO string
}
```

From backend/src/services/botController.ts (Phase 1 exports):
```typescript
export type BotState = 'stopped' | 'running' | 'paused';

export interface BotConfigRecord {
  enabledCatalystTiers: string;  // comma-separated "1,2,3,4" — parse with .split(',').map(Number)
  minWinRate: number;            // default 0.5
  maxSharePrice: number;         // default 20
  minRelativeVolume: number;     // default 5
  maxFloatShares: number;        // default 20_000_000
}

export function getBotState(): BotState;
export function getBotConfig(): BotConfigRecord;  // non-null after initBot()
export function isMarketOpen(): boolean;          // true 9:30–16:00 ET weekdays
```

From backend/src/services/catalystClassifier.ts:
```typescript
export interface CatalystClassification {
  category: CatalystCategory;
  tier: number;  // 1–5 (5 = OTHER)
}

// Returns null if a danger pattern matches (short-sell signals, dilution, FDA rejection, etc.)
export function classifyCatalystGranular(
  headline: string,
  body?: string
): CatalystClassification | null;
```

From backend/src/services/alpaca.ts (verified in priceTracker.ts usage):
```typescript
// Snapshot shape (confirmed from priceTracker.ts and scanner.ts usage):
interface Snapshot {
  ticker: string;
  price: number;          // latest trade price
  relativeVolume: number; // volume / 30-day avg volume
  volume: number;
  avgVolume30d: number;
  changePct: number;
  gapPct: number;
  high: number;
  low: number;
  hasNews: boolean;
}

export async function getSnapshots(tickers: string[]): Promise<Snapshot[]>;
// Returns [] on failure — always handles errors internally
```

From backend/src/services/strategyEngine.ts (verified in research):
```typescript
// StrategyRecommendation shape:
interface StrategyRecommendation {
  winRate: number;      // 0–1; is 0 when sampleSize === 0
  sampleSize: number;   // number of trades in the sample
  confidence: number;
  holdDurationSec: number;
  trailingStopPct: number;
}

export function getStrategy(
  category: string,
  capBucket: string | null,
  date: Date
): StrategyRecommendation;
```

From backend/src/db/client.ts (standard pattern across codebase):
```typescript
import prisma from "../db/client";
// prisma.botSignalLog.create({ data: { ... } })
```

Evaluation pipeline sequence (from research — implement in EXACTLY this order):
```
1. Guard: getBotState() === 'running'?           → NO: silent skip (no DB write)
2. Guard: isMarketOpen()?                        → NO: silent skip (no DB write)
3. Guard: isReconnectSuppressed(source)?         → YES: reject "reconnect-cooldown"
4. Guard: staleness (> 90 seconds old)?         → YES: reject "stale"
5. Guard: isDuplicate(symbol, title, source)?   → YES: silent skip (no DB write for dups)
6. Classify: classifyCatalystGranular(headline, body)
   → null:         reject "danger-pattern"
   → tier >= 5:    reject "tier-disabled" (OTHER)
7. Guard: tier in enabledCatalystTiers?         → NO: reject "tier-disabled"
8. Guard: isOpeningAuction()?                   → YES: reject "opening-auction"
9. Guard: strategy win rate >= minWinRate?      → NO: reject "below-win-rate"
   (bypass when sampleSize === 0 — log winRateAtEval: null)
10. 5 Pillars check via getSnapshots(symbol):
    → price > maxSharePrice: reject "failed-5-pillars", failedPillar: "price"
    → relVol < minRelativeVolume: reject "failed-5-pillars", failedPillar: "relative_volume"
    → both pass: continue
11. Branch on tier (Phase 2 — only tier 1-2 fast path, no AI yet):
    → tier 1-2: write BotSignalLog outcome="fired", rejectReason="log-only"
    → tier 3-4 (needsAI=true): write placeholder for now — outcome="skipped",
      rejectReason="ai-unavailable" (Plan 02-03 replaces this placeholder with real AI call)
12. All BotSignalLog writes use prisma.botSignalLog.create()
```

BotSignalLog Prisma model fields (from Plan 02-01):
```typescript
prisma.botSignalLog.create({
  data: {
    symbol: string,
    source: string,
    headline: string,
    catalystCategory: string | null,
    catalystTier: number | null,
    outcome: string,         // "fired" | "rejected" | "skipped"
    rejectReason: string | null,
    failedPillar: string | null,
    aiProceed: boolean | null,
    aiConfidence: string | null,
    aiReasoning: string | null,
    winRateAtEval: number | null,
    priceAtEval: number | null,
    relVolAtEval: number | null,
    articleCreatedAt: Date | null,
  }
})
```
</interfaces>

<tasks>

<task type="auto">
  <name>Task 1: Create signalEngine.ts with evaluation gauntlet and BotSignalLog writes</name>
  <files>backend/src/services/signalEngine.ts</files>
  <action>
    Create backend/src/services/signalEngine.ts implementing the full evaluation pipeline for non-AI code paths. This file must be complete and correct; Plan 02-03 only adds imports and replaces the "ai-unavailable" placeholder at step 11.

    Structure the file as follows:

    **Imports:**
    ```typescript
    import prisma from "../db/client";
    import { getBotState, getBotConfig, isMarketOpen } from "./botController";
    import { classifyCatalystGranular } from "./catalystClassifier";
    import { getSnapshots } from "./alpaca";
    import { getStrategy } from "./strategyEngine";
    import { RtprArticle } from "./rtpr";
    ```

    **Module-level state (three Maps — never exported directly):**

    1. Reconnect cooldown map:
    ```typescript
    const RECONNECT_SUPPRESS_MS = 30_000;
    const reconnectAt = new Map<string, number>(); // source → Date.now() at last reconnect
    ```

    2. Dedup map with cleanup:
    ```typescript
    const DEDUP_WINDOW_MS = 5 * 60 * 1000; // 5 minutes
    interface DedupEntry { firedAt: number; sources: string[]; }
    const dedupMap = new Map<string, DedupEntry>();
    // Cleanup every 5 minutes
    setInterval(() => {
      const cutoff = Date.now() - DEDUP_WINDOW_MS;
      for (const [key, entry] of dedupMap) {
        if (entry.firedAt < cutoff) dedupMap.delete(key);
      }
    }, DEDUP_WINDOW_MS);
    ```

    **Exported functions:**

    `export function notifyReconnect(source: string): void` — sets reconnectAt.set(source, Date.now())

    `export async function evaluateBotSignal(article: RtprArticle): Promise<void>` — full pipeline in a try/catch:

    Implement each step in the pipeline sequence from the interfaces section above, in order. Key implementation details:

    - Step 1 & 2 (silent skips): `if (getBotState() !== 'running' || !isMarketOpen()) return;`

    - Step 3 (reconnect cooldown check):
      ```typescript
      function isReconnectSuppressed(source: string): boolean {
        const ts = reconnectAt.get(source);
        return !!ts && Date.now() - ts < RECONNECT_SUPPRESS_MS;
      }
      ```

    - Step 4 (staleness — 90 seconds):
      ```typescript
      const MAX_ARTICLE_AGE_MS = 90_000;
      const articleAge = Date.now() - new Date(article.createdAt).getTime();
      ```

    - Step 5 (dedup — normalize title, keyed on `${symbol}|${normalizedTitle}`):
      ```typescript
      function isDuplicate(symbol: string, title: string, source: string): boolean {
        const key = `${symbol}|${title.toLowerCase().replace(/[^a-z0-9]/g, '')}`;
        const existing = dedupMap.get(key);
        if (existing && Date.now() - existing.firedAt < DEDUP_WINDOW_MS) {
          existing.sources.push(source);
          return true;  // silent skip — caller writes no DB record
        }
        dedupMap.set(key, { firedAt: Date.now(), sources: [source] });
        return false;
      }
      ```

    - Step 6 (classify): `classifyCatalystGranular(article.title, article.body)` — null → danger-pattern; tier >= 5 → tier-disabled

    - Step 7 (tier gate): `const enabledTiers = getBotConfig().enabledCatalystTiers.split(',').map(Number);`

    - Step 8 (opening auction — 9:30–9:45 AM ET):
      ```typescript
      function isOpeningAuction(): boolean {
        const etStr = new Date().toLocaleString('en-US', { timeZone: 'America/New_York' });
        const et = new Date(etStr);
        const totalMinutes = et.getHours() * 60 + et.getMinutes();
        return totalMinutes >= 9 * 60 + 30 && totalMinutes < 9 * 60 + 45;
      }
      ```

    - Step 9 (win-rate gate): Use `getStrategy(classification.category, null, new Date())`. Bypass when `strategy.sampleSize === 0` (log `winRateAtEval: null`).

    - Step 10 (5 Pillars): `const snaps = await getSnapshots([article.ticker])`. If snaps is empty, treat as failed pillar (reject "failed-5-pillars", failedPillar: "price"). Check price then relativeVolume.

    - Step 11 (Phase 2 placeholder): For tier 1-2, write `outcome: "fired", rejectReason: "log-only"`. For tier 3-4 (needsAI = classification.tier >= 3), write `outcome: "skipped", rejectReason: "ai-unavailable"`.

    **Helper function `writeSignalLog`:** Extract the `prisma.botSignalLog.create()` call into a private helper to avoid repetition:
    ```typescript
    async function writeSignalLog(data: Parameters<typeof prisma.botSignalLog.create>[0]['data']): Promise<void> {
      await prisma.botSignalLog.create({ data }).catch(err =>
        console.error('[SignalEngine] DB write error:', err instanceof Error ? err.message : err)
      );
    }
    ```

    **Error handling:** Wrap the entire body of `evaluateBotSignal` in try/catch. Log errors with `[SignalEngine]` prefix. Never throw from this function.

    ANTI-PATTERNS to avoid (from research):
    - Do NOT call notifyReconnect from ws.on("close") — Plan 02-03 will call it from ws.on("open") after first connect
    - Do NOT use a single global reconnect flag — the reconnectAt Map is per-source
    - Do NOT log entries when bot is not running — steps 1-2 must be silent skips
    - Do NOT hardcode the dedup key on article.createdAt — use normalized title text
  </action>
  <verify>
    cd c:/Projects/StockNews/backend && npx tsc --noEmit
    Must exit 0 with zero new TypeScript errors.
    Also verify file exists: ls backend/src/services/signalEngine.ts
    And confirm exports: grep "export" backend/src/services/signalEngine.ts
    Must show: export function evaluateBotSignal and export function notifyReconnect
  </verify>
  <done>
    signalEngine.ts exists with at least 150 lines; exports evaluateBotSignal and notifyReconnect;
    TypeScript compiles clean; the file implements all 11 pipeline steps including the "ai-unavailable" placeholder for tier 3-4.
  </done>
</task>

</tasks>

<verification>
After the task:
1. `cd c:/Projects/StockNews/backend && npx tsc --noEmit` — zero errors
2. `grep -c "export" backend/src/services/signalEngine.ts` — returns 2+ (evaluateBotSignal, notifyReconnect)
3. `grep "botSignalLog" backend/src/services/signalEngine.ts` — returns matches (DB writes are present)
4. `grep "reconnectAt" backend/src/services/signalEngine.ts` — returns matches (reconnect state exists)
5. `grep "dedupMap" backend/src/services/signalEngine.ts` — returns matches (dedup state exists)
</verification>

<success_criteria>
- signalEngine.ts created with all 11 pipeline steps in correct sequence
- evaluateBotSignal and notifyReconnect are exported
- All guard conditions write to BotSignalLog with the correct outcome and rejectReason
- Tier 1-2 fast path logs outcome="fired", rejectReason="log-only"
- Tier 3-4 placeholder logs outcome="skipped", rejectReason="ai-unavailable" (replaced in Plan 02-03)
- TypeScript compiles with zero errors
- No news service files are modified yet (that is Plan 02-03's responsibility)
</success_criteria>

<output>
After completion, create `.planning/phases/02-signal-engine/02-02-SUMMARY.md` following the summary template.
</output>
