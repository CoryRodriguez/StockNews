---
phase: 02-signal-engine
plan: "03"
type: execute
wave: 3
depends_on:
  - "02-02"
files_modified:
  - backend/src/services/signalEngine.ts
  - backend/src/services/rtpr.ts
  - backend/src/services/alpacaNews.ts
  - backend/src/services/benzinga.ts
autonomous: true
requirements:
  - SIG-01
  - SIG-11

must_haves:
  truths:
    - "A tier 3-4 article that passes all gate checks is sent to the Claude API and the response is logged in BotSignalLog within 2 seconds"
    - "When the Claude API times out, the article logs outcome='rejected', rejectReason='ai-timeout' — no crash"
    - "When ANTHROPIC_API_KEY is absent (empty string), tier 3-4 articles log rejectReason='ai-unavailable' instead of crashing"
    - "An RtprArticle flowing through rtpr.ts calls evaluateBotSignal(article).catch() after the existing executePaperTrade block"
    - "An RtprArticle flowing through alpacaNews.ts calls evaluateBotSignal(article).catch() after the existing executePaperTrade block"
    - "An RtprArticle flowing through benzinga.ts calls evaluateBotSignal(article).catch() after the existing executePaperTrade block"
    - "RTPR WebSocket reconnect (ws.on 'open' after first connect) calls notifyReconnect('rtpr')"
    - "AlpacaNews WebSocket reconnect (ws.on 'open' after first connect) calls notifyReconnect('alpaca')"
    - "Benzinga does NOT call notifyReconnect — it is a REST poller with no WebSocket reconnect lifecycle"
    - "TypeScript compiles with zero errors across all modified files"
  artifacts:
    - path: "backend/src/services/signalEngine.ts"
      provides: "Complete signal pipeline including Claude AI evaluation for tier 3-4 articles"
      contains: "evaluateWithAI"
    - path: "backend/src/services/rtpr.ts"
      provides: "Hook: evaluateBotSignal + notifyReconnect on reconnect"
      contains: "evaluateBotSignal"
    - path: "backend/src/services/alpacaNews.ts"
      provides: "Hook: evaluateBotSignal + notifyReconnect on reconnect"
      contains: "evaluateBotSignal"
    - path: "backend/src/services/benzinga.ts"
      provides: "Hook: evaluateBotSignal (no notifyReconnect — REST poller)"
      contains: "evaluateBotSignal"
  key_links:
    - from: "backend/src/services/rtpr.ts"
      to: "backend/src/services/signalEngine.ts"
      via: "import { evaluateBotSignal, notifyReconnect }"
      pattern: "evaluateBotSignal\\(article\\)"
    - from: "backend/src/services/alpacaNews.ts"
      to: "backend/src/services/signalEngine.ts"
      via: "import { evaluateBotSignal, notifyReconnect }"
      pattern: "evaluateBotSignal\\(article\\)"
    - from: "backend/src/services/benzinga.ts"
      to: "backend/src/services/signalEngine.ts"
      via: "import { evaluateBotSignal }"
      pattern: "evaluateBotSignal\\(article\\)"
    - from: "backend/src/services/signalEngine.ts"
      to: "Anthropic Claude API"
      via: "@anthropic-ai/sdk client.messages.create with timeout:2000"
      pattern: "messages\\.create"
---

<objective>
Complete signalEngine.ts by replacing the "ai-unavailable" placeholder with a real Claude API call for tier 3-4 articles. Then hook evaluateBotSignal into all three news services (rtpr, alpacaNews, benzinga) and wire reconnect notifications into the two WebSocket services.

Purpose: SIG-01 requires all three news feeds to route through the signal engine. SIG-11 requires Claude API evaluation for tier 3-4 and unclassified articles. This plan closes both requirements.

Output: signalEngine.ts has a working evaluateWithAI() function; all three news service files import and call evaluateBotSignal; RTPR and AlpacaNews call notifyReconnect on WebSocket reconnect.
</objective>

<execution_context>
@C:/Users/Owner/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Owner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/02-signal-engine/02-RESEARCH.md

@.planning/phases/02-signal-engine/02-02-SUMMARY.md
</context>

<interfaces>
<!-- Key contracts the executor needs. -->

From backend/src/config.ts (after Plan 02-01):
```typescript
export const config = {
  // ... existing fields ...
  anthropicApiKey: process.env.ANTHROPIC_API_KEY ?? "",
  claudeSignalModel: "claude-haiku-4-5-20251022",
};
```

From @anthropic-ai/sdk (verified from official docs in research):
```typescript
import Anthropic from "@anthropic-ai/sdk";

// Module-level singleton (lazy init)
const client = new Anthropic({
  apiKey: config.anthropicApiKey,
  timeout: 2000,  // 2 seconds — enforces SIG-11 requirement
});

const response = await client.messages.create({
  model: config.claudeSignalModel,
  max_tokens: 150,
  system: "System prompt",
  messages: [{ role: "user", content: "User message" }]
});

// Access text:
const text = response.content[0]?.type === "text" ? response.content[0].text : "";
```

Expected AI response JSON structure (parse with JSON.parse):
```typescript
interface AiEvaluation {
  proceed: boolean;
  confidence: 'high' | 'medium' | 'low';
  reasoning: string;
}
```

From backend/src/services/rtpr.ts (existing structure — modify minimally):
```typescript
// EXISTING ws.on("open") handler — add reconnect tracking:
let hasConnectedOnce = false;
ws.on("open", () => {
  if (hasConnectedOnce) {
    notifyReconnect('rtpr');
  }
  hasConnectedOnce = true;
  // ... existing auth/subscribe logic stays ...
});

// EXISTING handleMessage — add evaluateBotSignal AFTER executePaperTrade:
// In the article handler, after the executePaperTrade block:
evaluateBotSignal(article).catch((err) =>
  console.error("[RTPR] SignalEngine error:", err instanceof Error ? err.message : err)
);
```

From backend/src/services/alpacaNews.ts (existing structure — modify minimally):
```typescript
// Same pattern as rtpr.ts:
let hasConnectedOnce = false;
ws.on("open", () => {
  if (hasConnectedOnce) {
    notifyReconnect('alpaca');
  }
  hasConnectedOnce = true;
  // ... existing auth send ...
});

// In handleMessage, after the executePaperTrade block (inside the for..of tickers loop):
evaluateBotSignal(article).catch((err) =>
  console.error("[AlpacaNews] SignalEngine error:", err instanceof Error ? err.message : err)
);
```

From backend/src/services/benzinga.ts (REST poller — no reconnect):
```typescript
// In the for..of articles loop, after the executePaperTrade block:
evaluateBotSignal(article).catch((err) =>
  console.error("[Benzinga] SignalEngine error:", err instanceof Error ? err.message : err)
);
// NO notifyReconnect call — Benzinga is stateless REST polling
```

CRITICAL: In each service, evaluateBotSignal is added for ALL articles regardless of whether activeScanners is non-empty. The existing `if (activeScanners.length > 0)` guard is only for executePaperTrade — do NOT put evaluateBotSignal inside that guard.

Exact insertion points in each service file:
- rtpr.ts: After the `executePaperTrade(article, activeScanners).catch(...)` block (inside handleMessage, inside the article type check)
- alpacaNews.ts: After the `executePaperTrade(article, activeScanners).catch(...)` block (inside the for..of tickers loop)
- benzinga.ts: After the `executePaperTrade(article, activeScanners).catch(...)` block (inside the for..of articles loop)

All three are UNCONDITIONAL — not wrapped in any if-statement.
</interfaces>

<tasks>

<task type="auto">
  <name>Task 1: Add Claude AI evaluation to signalEngine.ts (replace ai-unavailable placeholder)</name>
  <files>backend/src/services/signalEngine.ts</files>
  <action>
    Modify backend/src/services/signalEngine.ts to add Claude API evaluation. Plan 02-02 left a placeholder at step 11 where tier 3-4 articles log "ai-unavailable". Replace that placeholder with a real AI evaluation call.

    **Add to imports at top of file:**
    ```typescript
    import Anthropic from "@anthropic-ai/sdk";
    import { config } from "../config";
    ```

    **Add module-level lazy-init client (after the existing module-level Map declarations):**
    ```typescript
    let anthropicClient: Anthropic | null = null;

    function getAnthropicClient(): Anthropic | null {
      if (!config.anthropicApiKey) return null; // key absent — no crash
      if (!anthropicClient) {
        anthropicClient = new Anthropic({
          apiKey: config.anthropicApiKey,
          timeout: 2000,
        });
      }
      return anthropicClient;
    }
    ```

    **Add evaluateWithAI helper function (private, not exported):**
    ```typescript
    interface AiEvaluation {
      proceed: boolean;
      confidence: 'high' | 'medium' | 'low';
      reasoning: string;
    }

    async function evaluateWithAI(
      symbol: string,
      headline: string,
      body: string,
      priceAtEval: number,
      relVolAtEval: number
    ): Promise<AiEvaluation | null> {
      const client = getAnthropicClient();
      if (!client) return null; // signals "ai-unavailable" to caller

      try {
        const response = await client.messages.create({
          model: config.claudeSignalModel,
          max_tokens: 150,
          system: `You are a day-trading signal evaluator. Evaluate if a news headline warrants a momentum buy.
    Respond with JSON only: {"proceed": true|false, "confidence": "high"|"medium"|"low", "reasoning": "one sentence"}.
    Rules: proceed=true only for clear positive catalysts with strong momentum potential. Decline vague, speculative, or negative news.`,
          messages: [{
            role: "user",
            content: `Symbol: ${symbol}\nHeadline: ${headline}\nBody: ${body.slice(0, 300)}\nPrice: $${priceAtEval.toFixed(2)}, RelVol: ${relVolAtEval.toFixed(1)}x`
          }]
        });

        const text = response.content[0]?.type === "text" ? response.content[0].text : "";
        return JSON.parse(text) as AiEvaluation;
      } catch (err) {
        console.warn("[SignalEngine] AI evaluation failed:", err instanceof Error ? err.message : err);
        return null; // null signals timeout/error to caller
      }
    }
    ```

    **Replace the tier 3-4 placeholder at step 11** of evaluateBotSignal.

    The placeholder was:
    ```typescript
    // Plan 02-03 replaces this
    // outcome="skipped", rejectReason="ai-unavailable"
    ```

    Replace with:
    ```typescript
    // Tier 3-4: send to Claude API
    const aiResult = await evaluateWithAI(
      article.ticker,
      article.title,
      article.body,
      priceAtEval,   // from step 10 snapshot
      relVolAtEval   // from step 10 snapshot
    );

    if (aiResult === null) {
      // null = either key absent OR timeout/error
      const reason = getAnthropicClient() === null ? 'ai-unavailable' : 'ai-timeout';
      await writeSignalLog({
        symbol: article.ticker, source: article.source, headline: article.title,
        catalystCategory: classification.category, catalystTier: classification.tier,
        outcome: 'rejected', rejectReason: reason,
        winRateAtEval, priceAtEval, relVolAtEval,
        articleCreatedAt: new Date(article.createdAt),
      });
      return;
    }

    if (!aiResult.proceed) {
      await writeSignalLog({
        symbol: article.ticker, source: article.source, headline: article.title,
        catalystCategory: classification.category, catalystTier: classification.tier,
        outcome: 'rejected', rejectReason: 'ai-declined',
        aiProceed: false, aiConfidence: aiResult.confidence, aiReasoning: aiResult.reasoning,
        winRateAtEval, priceAtEval, relVolAtEval,
        articleCreatedAt: new Date(article.createdAt),
      });
      return;
    }

    // AI approved — log-only (Phase 2: no order placed)
    await writeSignalLog({
      symbol: article.ticker, source: article.source, headline: article.title,
      catalystCategory: classification.category, catalystTier: classification.tier,
      outcome: 'fired', rejectReason: 'log-only',
      aiProceed: true, aiConfidence: aiResult.confidence, aiReasoning: aiResult.reasoning,
      winRateAtEval, priceAtEval, relVolAtEval,
      articleCreatedAt: new Date(article.createdAt),
    });
    ```

    IMPORTANT: The variables `priceAtEval`, `relVolAtEval`, and `winRateAtEval` must be captured earlier in the pipeline (at step 9/10) and reused in these log writes. Ensure the snapshot result from step 10 stores `priceAtEval = snap.price` and `relVolAtEval = snap.relativeVolume` before the branch point.

    After editing, run:
    `cd c:/Projects/StockNews/backend && npx tsc --noEmit`
    Fix any TypeScript errors before proceeding to Task 2.
  </action>
  <verify>
    cd c:/Projects/StockNews/backend && npx tsc --noEmit
    Zero errors.
    grep "evaluateWithAI" backend/src/services/signalEngine.ts — must return matches.
    grep "ai-timeout\|ai-unavailable\|ai-declined" backend/src/services/signalEngine.ts — must return 3 matches.
  </verify>
  <done>
    signalEngine.ts has evaluateWithAI function; all three AI outcomes (ai-unavailable, ai-timeout, ai-declined) are handled with correct BotSignalLog writes; TypeScript compiles clean.
  </done>
</task>

<task type="auto">
  <name>Task 2: Hook evaluateBotSignal into rtpr.ts, alpacaNews.ts, and benzinga.ts</name>
  <files>
    backend/src/services/rtpr.ts
    backend/src/services/alpacaNews.ts
    backend/src/services/benzinga.ts
  </files>
  <action>
    Add the signal engine hook to each of the three news services. These are minimal, surgical changes — no service internals are modified. Read each file carefully before editing.

    **rtpr.ts changes (2 changes):**

    Change 1 — Add import at top (after existing imports):
    ```typescript
    import { evaluateBotSignal, notifyReconnect } from "./signalEngine";
    ```

    Change 2 — Add `hasConnectedOnce` flag and update the `ws.on("open")` handler.
    The existing handler only does auth. Add reconnect tracking before the existing auth logic:
    ```typescript
    let hasConnectedOnce = false;
    // Inside connect():
    ws.on("open", () => {
      if (hasConnectedOnce) {
        notifyReconnect('rtpr');
      }
      hasConnectedOnce = true;
      console.log("[RTPR] Connected");
      ws!.send(JSON.stringify({ action: "subscribe", tickers: ["*"] }));
    });
    ```

    Change 3 — Add evaluateBotSignal call in handleMessage, UNCONDITIONALLY after the executePaperTrade block:
    ```typescript
    // EXISTING (do not touch):
    const activeScanners = getActiveScannersForTicker(article.ticker);
    if (activeScanners.length > 0) {
      executePaperTrade(article, activeScanners).catch((err) =>
        console.error("[PaperTrader] Uncaught error:", err)
      );
    }

    // NEW — add after the closing brace above:
    evaluateBotSignal(article).catch((err) =>
      console.error("[RTPR] SignalEngine error:", err instanceof Error ? err.message : err)
    );
    ```

    ---

    **alpacaNews.ts changes (2 changes):**

    Change 1 — Add import:
    ```typescript
    import { evaluateBotSignal, notifyReconnect } from "./signalEngine";
    ```

    Change 2 — Add reconnect tracking in ws.on("open"). The existing handler sends auth JSON. Add before the send:
    ```typescript
    let hasConnectedOnce = false;
    // Inside connect():
    ws.on("open", () => {
      if (hasConnectedOnce) {
        notifyReconnect('alpaca');
      }
      hasConnectedOnce = true;
      ws!.send(
        JSON.stringify({
          action: "auth",
          key: config.alpacaApiKey,
          secret: config.alpacaApiSecret,
        })
      );
    });
    ```

    Change 3 — Add evaluateBotSignal inside the `for (const ticker of tickers)` loop in handleMessage, UNCONDITIONALLY after the executePaperTrade block:
    ```typescript
    // EXISTING (do not touch):
    const activeScanners = getActiveScannersForTicker(ticker);
    if (activeScanners.length > 0) {
      executePaperTrade(article, activeScanners).catch((err) =>
        console.error("[AlpacaNews] PaperTrader error:", err)
      );
    }

    // NEW — after the closing brace above:
    evaluateBotSignal(article).catch((err) =>
      console.error("[AlpacaNews] SignalEngine error:", err instanceof Error ? err.message : err)
    );
    ```

    ---

    **benzinga.ts changes (1 change only — no reconnect):**

    Change 1 — Add import:
    ```typescript
    import { evaluateBotSignal } from "./signalEngine";
    ```
    Note: Import only evaluateBotSignal, NOT notifyReconnect (Benzinga is a REST poller with no WebSocket).

    Change 2 — Add evaluateBotSignal inside the `for (const ticker of tickers)` loop in poll(), UNCONDITIONALLY after the executePaperTrade block:
    ```typescript
    // EXISTING (do not touch):
    const activeScanners = getActiveScannersForTicker(ticker);
    if (activeScanners.length > 0) {
      executePaperTrade(article, activeScanners).catch((err) =>
        console.error("[Benzinga] PaperTrader error:", err)
      );
    }

    // NEW — after the closing brace above:
    evaluateBotSignal(article).catch((err) =>
      console.error("[Benzinga] SignalEngine error:", err instanceof Error ? err.message : err)
    );
    ```

    After all three edits, run TypeScript compile:
    `cd c:/Projects/StockNews/backend && npx tsc --noEmit`
    Zero errors expected across all service files.
  </action>
  <verify>
    cd c:/Projects/StockNews/backend && npx tsc --noEmit
    Zero errors.
    grep "evaluateBotSignal" backend/src/services/rtpr.ts — match found.
    grep "evaluateBotSignal" backend/src/services/alpacaNews.ts — match found.
    grep "evaluateBotSignal" backend/src/services/benzinga.ts — match found.
    grep "notifyReconnect" backend/src/services/rtpr.ts — match found.
    grep "notifyReconnect" backend/src/services/alpacaNews.ts — match found.
    grep "notifyReconnect" backend/src/services/benzinga.ts — must return NO match (benzinga is a REST poller).
  </verify>
  <done>
    All 3 news service files import and call evaluateBotSignal unconditionally;
    rtpr.ts and alpacaNews.ts call notifyReconnect on reconnect (using hasConnectedOnce flag);
    benzinga.ts does NOT call notifyReconnect;
    TypeScript compiles with zero errors.
  </done>
</task>

</tasks>

<verification>
After both tasks complete:
1. `cd c:/Projects/StockNews/backend && npx tsc --noEmit` — zero errors across all modified files
2. `grep -l "evaluateBotSignal" backend/src/services/rtpr.ts backend/src/services/alpacaNews.ts backend/src/services/benzinga.ts` — all 3 files listed
3. `grep "notifyReconnect" backend/src/services/benzinga.ts` — empty output (correct — no reconnect for REST poller)
4. `grep "evaluateWithAI\|ai-timeout\|ai-declined\|ai-unavailable" backend/src/services/signalEngine.ts` — multiple matches
5. `grep "log-only" backend/src/services/signalEngine.ts` — matches in both tier 1-2 and AI-approved branches
</verification>

<success_criteria>
- signalEngine.ts has working Claude API integration with 2-second timeout and graceful fallback
- All three AI outcome paths (ai-unavailable, ai-timeout, ai-declined) write correct BotSignalLog records
- All three news services call evaluateBotSignal unconditionally for every article
- RTPR and AlpacaNews WebSocket reconnects call notifyReconnect with correct source string
- Benzinga does not call notifyReconnect
- TypeScript compiles clean across all 4 modified files
- The existing executePaperTrade flow is completely unchanged — only lines were added, nothing removed
</success_criteria>

<output>
After completion, create `.planning/phases/02-signal-engine/02-03-SUMMARY.md` following the summary template.
</output>
