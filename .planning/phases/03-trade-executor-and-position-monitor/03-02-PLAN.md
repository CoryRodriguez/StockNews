---
phase: 03-trade-executor-and-position-monitor
plan: "02"
type: execute
wave: 2
depends_on:
  - "03-01"
files_modified:
  - backend/src/services/tradeExecutor.ts
  - backend/src/services/tradingWs.ts
autonomous: true
requirements:
  - EXEC-01
  - EXEC-02
  - EXEC-03
  - EXEC-04
  - EXEC-05
  - EXEC-06
  - EXEC-07

must_haves:
  truths:
    - "tradeExecutor.ts exports executeTradeAsync() that places a notional buy order and persists a BotTrade record"
    - "executeTradeAsync() resolves notional dollar amount from star rating (tier 1-2 = stars5 amount, tier 3-4 maps to AI confidence, null AI = skip)"
    - "A second signal for a symbol with an open BotTrade is silently skipped without a DB write"
    - "tradingWs.ts connects to the Alpaca trading WebSocket, authenticates, subscribes to trade_updates"
    - "fill and partial_fill events from tradingWs update the BotTrade record (filled_avg_price → entryPrice, filled_qty → shares)"
    - "partial_fill events also call GET /v2/positions/{symbol} to get the authoritative share count"
    - "rejected events log the rejection reason without crashing"
  artifacts:
    - path: "backend/src/services/tradeExecutor.ts"
      provides: "Async trade entry — notional buy order + BotTrade lifecycle"
      exports:
        - "executeTradeAsync"
    - path: "backend/src/services/tradingWs.ts"
      provides: "Alpaca trading WebSocket — fill/partial_fill/rejected event handler"
      exports:
        - "startTradingWs"
        - "restartTradingWs"
  key_links:
    - from: "backend/src/services/tradingWs.ts onTradeUpdate"
      to: "backend/src/services/tradeExecutor.ts onFillEvent"
      via: "exported callback registered by tradeExecutor"
      pattern: "onFillEvent|registerFillHandler"
    - from: "backend/src/services/tradeExecutor.ts"
      to: "backend/prisma/schema.prisma BotTrade"
      via: "prisma.botTrade.create + prisma.botTrade.update"
      pattern: "prisma.botTrade"
---

<objective>
Create two new services: `tradeExecutor.ts` (async order placement + BotTrade persistence) and `tradingWs.ts` (Alpaca trading WebSocket for fill confirmation). Together these implement the full buy-side execution pipeline (EXEC-01 through EXEC-07).

Purpose: The signal engine currently logs "log-only" for fired signals. These services replace that placeholder with real order placement that is fire-and-forget (never blocks the news handler) and self-confirms via WebSocket fill events.

Output: Two new TypeScript files in backend/src/services/. Neither is wired into the startup sequence yet — that happens in Plan 03-04.
</objective>

<execution_context>
@C:/Users/Owner/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Owner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-trade-executor-and-position-monitor/CONTEXT.md
@.planning/phases/03-trade-executor-and-position-monitor/03-RESEARCH.md
@.planning/phases/03-trade-executor-and-position-monitor/03-01-SUMMARY.md

<interfaces>
<!-- botController.ts exports used by tradeExecutor.ts: -->
```typescript
export type BotState = 'stopped' | 'running' | 'paused';
export type BotMode = 'paper' | 'live';

export interface BotConfigRecord {
  id: string; enabled: boolean; state: string; mode: string;
  positionSizeUsd: number;
  confidenceMultiplierHigh: number; confidenceMultiplierMed: number; confidenceMultiplierLow: number;
  maxConcurrentPositions: number; dailyLossLimitUsd: number; minWinRate: number;
  hardStopLossPct: number; maxHoldDurationSec: number;
  enabledCatalystTiers: string;
  maxFloatShares: number; maxSharePrice: number; minRelativeVolume: number;
  tradeSizeStars3: number;  // $50 default — added in Plan 03-01
  tradeSizeStars4: number;  // $75 default — added in Plan 03-01
  tradeSizeStars5: number;  // $100 default — added in Plan 03-01
  profitTargetPct: number;  // 10% default — added in Plan 03-01
  updatedAt: Date;
}

export function getAlpacaBaseUrl(): string;
export function getBotConfig(): BotConfigRecord;
export function getBotState(): BotState;
export function isMarketOpen(): boolean;
```

<!-- config.ts fields used: -->
```typescript
// from backend/src/config.ts
config.alpacaApiKey     // APCA-API-Key-ID header value
config.alpacaApiSecret  // APCA-API-Secret-Key header value
config.alpacaPaperUrl   // https://paper-api.alpaca.markets
config.alpacaLiveUrl    // https://api.alpaca.markets
```

<!-- BotTrade Prisma model: -->
```prisma
model BotTrade {
  id             String    @id @default(cuid())
  symbol         String
  entryPrice     Float?
  exitPrice      Float?
  shares         Float?
  pnl            Float?
  catalystType   String?
  catalystTier   Int?
  exitReason     String?
  status         String    // "open" | "closed" | "missed"
  alpacaOrderId  String?
  entryAt        DateTime?
  exitAt         DateTime?
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt
}
```

<!-- Alpaca REST API types (from research): -->
```typescript
interface AlpacaOrderRequest {
  symbol: string;
  notional: number;      // dollar amount — mutually exclusive with qty
  side: 'buy' | 'sell';
  type: 'market';
  time_in_force: 'day';
}

interface AlpacaOrderResponse {
  id: string;
  status: string;             // "new" | "accepted" | "pending_new" | "filled" | "rejected"
  symbol: string;
  notional: string | null;
  qty: string | null;         // null when order was submitted with notional
  filled_qty: string;         // shares actually filled
  filled_avg_price: string | null;
  side: string;
  created_at: string;
}

// Trading WebSocket message schema
interface TradingWsMessage {
  stream: 'trade_updates' | 'authorization' | 'listening';
  data: TradeUpdate | AuthResult;
}

interface TradeUpdate {
  event: 'fill' | 'partial_fill' | 'rejected' | 'new' | 'canceled' | 'expired' | 'done_for_day';
  timestamp: string;
  price?: string;
  qty?: string;
  position_qty?: string;
  order: AlpacaOrderResponse;
}

interface AlpacaPosition {
  symbol: string;
  qty: string;               // total shares held — parse with parseFloat
  avg_entry_price: string;
  current_price: string;
  unrealized_plpc: string;  // % P&L
}
```

<!-- paperTrader.ts pattern reference — DO NOT MODIFY THIS FILE: -->
The existing paperTrader.ts uses placeOrder() with qty-based orders. Phase 3 uses notional instead.
The `sold` boolean guard pattern from paperTrader.ts must be replicated in positionMonitor.ts (Plan 03-03),
not here. tradeExecutor.ts only handles the buy side.
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create tradeExecutor.ts — async notional buy + BotTrade lifecycle</name>
  <files>backend/src/services/tradeExecutor.ts</files>
  <action>
Create `backend/src/services/tradeExecutor.ts`. This service handles the buy side only. The sell side (exit conditions) is in positionMonitor.ts (Plan 03-03).

The file must implement:

**Star-rating sizing (EXEC-07, per CONTEXT.md locked decisions):**
```typescript
type StarRating = 3 | 4 | 5;

function getStarRating(tier: number, aiConfidence: 'high' | 'medium' | 'low' | null): StarRating | null {
  if (tier <= 2) return 5;                  // tier 1-2: always top confidence
  if (aiConfidence === 'high') return 5;
  if (aiConfidence === 'medium') return 4;
  if (aiConfidence === 'low') return 3;
  return null;                              // null AI = skip (1-2 star per CONTEXT.md)
}

function getNotional(starRating: StarRating): number {
  const cfg = getBotConfig();
  if (starRating === 5) return cfg.tradeSizeStars5;  // $100 default
  if (starRating === 4) return cfg.tradeSizeStars4;  // $75 default
  return cfg.tradeSizeStars3;                        // $50 default
}
```

**Duplicate open position check (CONTEXT.md: silent skip, no DB write):**
```typescript
async function hasOpenPosition(symbol: string): Promise<boolean> {
  const count = await prisma.botTrade.count({ where: { symbol, status: 'open' } });
  return count > 0;
}
```

**Alpaca notional buy (EXEC-01, EXEC-05):**
- POST to `${getAlpacaBaseUrl()}/v2/orders` with `notional` field (NOT `qty`)
- Headers: `APCA-API-Key-ID` + `APCA-API-Secret-Key`
- Body: `{ symbol, notional, side: 'buy', type: 'market', time_in_force: 'day' }`
- If response not ok: log error with status code and body text, log the rejection reason to console — do NOT throw (EXEC-04)
- Return the AlpacaOrderResponse on success, null on failure

**BotTrade creation:**
- Create BotTrade record immediately when order placement is attempted (status: 'open', alpacaOrderId from response)
- `entryAt: new Date()`, `catalystType`, `catalystTier` from signal parameters
- `entryPrice` and `shares` start as null — filled in by fill event handler (see onFillEvent below)

**Fill event handler (EXEC-02, EXEC-03):**
Export a callback that tradingWs.ts can call when fill/partial_fill events arrive:

```typescript
// Called by tradingWs.ts when a fill or partial_fill arrives
export async function onFillEvent(update: {
  event: 'fill' | 'partial_fill';
  orderId: string;
  filledQty: string;
  filledAvgPrice: string | null;
  symbol: string;
}): Promise<void>
```

For `fill` events: update BotTrade where `alpacaOrderId === orderId` with `entryPrice = parseFloat(filledAvgPrice)`, `shares = parseFloat(filledQty)`.

For `partial_fill` events: call `GET /v2/positions/{symbol}` to get authoritative qty (EXEC-03 — never trust WebSocket qty alone). Update BotTrade `shares` with the authoritative `parseFloat(position.qty)`.

**Rejection event handler (EXEC-04):**
```typescript
export async function onRejectedEvent(update: { orderId: string; symbol: string; reason?: string }): Promise<void>
```
Update BotTrade where `alpacaOrderId === orderId` to `status: 'missed'`, `exitReason: 'alpaca_rejected'`. Log: `[TradeExecutor] Order rejected: ${symbol} orderId=${orderId}`.

**Main exported function (EXEC-06 — fire-and-forget):**
```typescript
export interface TradeSignal {
  symbol: string;
  catalystCategory: string;
  catalystTier: number;
  aiConfidence: 'high' | 'medium' | 'low' | null;
  priceAtSignal: number;
}

export async function executeTradeAsync(signal: TradeSignal): Promise<void>
```

This is the inner async function called via `void executeTradeAsync(signal).catch(err => console.error(...))` from signalEngine.ts. It does NOT need to be wrapped here — the fire-and-forget wrapper is in signalEngine.ts.

Logic:
1. Compute star rating → if null, return (silent skip)
2. Check `hasOpenPosition(symbol)` → if true, return (silent skip, no DB write per CONTEXT.md)
3. Compute notional from star rating
4. Place buy order → if response is null (failed), return (error already logged)
5. Create BotTrade record with status: 'open', alpacaOrderId, catalystType, catalystTier, entryAt

DO NOT import positionMonitor.ts here — circular dependency. positionMonitor.addPosition() is called from botController.ts after fill events confirm entryPrice (Plan 03-04 wires this).

IMPORTANT anti-patterns to avoid:
- Never use `await` for this function from news handlers — that's the caller's responsibility
- Never send `qty` in the Alpaca order body — only `notional` (EXEC-05)
- Never hardcode dollar amounts — always read from getBotConfig()
  </action>
  <verify>
    <automated>cd C:/Projects/StockNews/backend && rtk tsc --noEmit 2>&1 | head -30</automated>
  </verify>
  <done>tradeExecutor.ts compiles without TypeScript errors; exports executeTradeAsync, onFillEvent, onRejectedEvent, TradeSignal type; tsc --noEmit passes</done>
</task>

<task type="auto">
  <name>Task 2: Create tradingWs.ts — Alpaca trading WebSocket with reconnect</name>
  <files>backend/src/services/tradingWs.ts</files>
  <action>
Create `backend/src/services/tradingWs.ts`. This is a SEPARATE WebSocket from the market data stream in alpaca.ts. It connects to the Alpaca trading stream endpoint and dispatches fill/partial_fill/rejected events to tradeExecutor.ts.

The file must implement:

**WebSocket URL derivation (critical — mode-aware, from research pitfall #1):**
```typescript
function getTradingWsUrl(): string {
  return getAlpacaBaseUrl()
    .replace('https://', 'wss://')
    .replace('http://', 'ws://') + '/stream';
}
// Paper: wss://paper-api.alpaca.markets/stream
// Live:  wss://api.alpaca.markets/stream
```

**Connection lifecycle (mirror alpaca.ts reconnect pattern):**
- Module-level: `let tradingWs: WebSocket | null = null` and `let reconnectTimer: ReturnType<typeof setTimeout> | null = null`
- `connectTradingWs()`: create WebSocket, attach event handlers
- On `open`: send auth message immediately: `{ action: 'auth', key: config.alpacaApiKey, secret: config.alpacaApiSecret }`
- On `message`: parse JSON, dispatch to `handleTradingWsMessage()`
- On `close`: log warning + schedule reconnect in 5s (same as alpaca.ts pattern)
- On `error`: log error message only, do not crash

**Authentication flow:**
- After `open`, send auth message
- On `stream: 'authorization'` with `data.status === 'authorized'`: send subscribe message: `{ action: 'listen', data: { streams: ['trade_updates'] } }`
- Log: `[TradingWs] Authenticated — subscribed to trade_updates`
- If auth status is NOT 'authorized': log error + do NOT subscribe

**Message dispatch (EXEC-02, EXEC-04):**
On `stream: 'trade_updates'`, call the appropriate tradeExecutor handlers:
- `event === 'fill'` or `event === 'partial_fill'` → call `onFillEvent({ event, orderId: update.order.id, filledQty: update.order.filled_qty, filledAvgPrice: update.order.filled_avg_price, symbol: update.order.symbol })`
- `event === 'rejected'` → call `onRejectedEvent({ orderId: update.order.id, symbol: update.order.symbol })`
- Other events (`new`, `canceled`, `expired`, `done_for_day`): log at debug level, no action needed

**Exported functions:**
```typescript
export function startTradingWs(): void
export function restartTradingWs(): void  // called by switchMode() in Plan 03-04
```

`startTradingWs()`: guard against missing API key (`if (!config.alpacaApiKey) { console.warn('[TradingWs] No API key — trading stream disabled'); return; }`), then call `connectTradingWs()`.

`restartTradingWs()`: close existing socket if open (`tradingWs?.close()`), clear any pending reconnect timer, then call `connectTradingWs()` after 100ms to ensure socket is closed first.

IMPORTANT: Wrap all message handling in try/catch. A bad JSON message must not crash the WebSocket handler. Do NOT import positionMonitor.ts — this service only dispatches to tradeExecutor.ts callbacks.
  </action>
  <verify>
    <automated>cd C:/Projects/StockNews/backend && rtk tsc --noEmit 2>&1 | head -30</automated>
  </verify>
  <done>tradingWs.ts compiles without TypeScript errors; exports startTradingWs and restartTradingWs; tsc --noEmit passes for both new files</done>
</task>

</tasks>

<verification>
Final check after both tasks:
1. `cd C:/Projects/StockNews/backend && rtk tsc --noEmit` — must produce zero errors
2. `grep -l "executeTradeAsync\|onFillEvent\|onRejectedEvent" backend/src/services/tradeExecutor.ts` — all three must be in the file
3. `grep -l "startTradingWs\|restartTradingWs\|trade_updates" backend/src/services/tradingWs.ts` — all three must be in the file
4. `grep "await executeTradeAsync" backend/src/services/tradeExecutor.ts` — must return empty (no self-await; fire-and-forget is the CALLER's job)
</verification>

<success_criteria>
- tradeExecutor.ts: getStarRating() maps tier/aiConfidence → 3|4|5|null; getNotional() reads from getBotConfig(); executeTradeAsync() places notional buy and creates BotTrade; onFillEvent() updates BotTrade on fill/partial_fill; onRejectedEvent() marks BotTrade as missed
- tradingWs.ts: connects to mode-aware Alpaca trading stream URL; authenticates; subscribes to trade_updates; routes fill/partial_fill/rejected events to tradeExecutor handlers; reconnects on disconnect
- tsc --noEmit: zero errors across both files
- No hardcoded dollar amounts in tradeExecutor.ts
- No qty field in the buy order POST body
</success_criteria>

<output>
After completion, create `.planning/phases/03-trade-executor-and-position-monitor/03-02-SUMMARY.md`
</output>
