---
phase: 03-trade-executor-and-position-monitor
plan: "03"
type: execute
wave: 2
depends_on:
  - "03-01"
files_modified:
  - backend/src/services/positionMonitor.ts
autonomous: true
requirements:
  - EXIT-01
  - EXIT-03
  - EXIT-04
  - EXIT-05
  - EXIT-06

must_haves:
  truths:
    - "positionMonitor polls all open positions every 5 seconds using existing getSnapshots() infrastructure"
    - "Hard stop fires when (currentPrice - entryPrice) / entryPrice * 100 <= -(stopLossPct) from BotConfig"
    - "Profit target fires when pct change >= profitTargetPct from BotConfig"
    - "Time exit fires when hold duration in minutes >= maxHoldDurationSec / 60"
    - "All three exit conditions place a market sell order on Alpaca and update BotTrade to status=closed"
    - "A sold boolean guard prevents double-exit race conditions"
    - "node-cron job fires at 3:45 PM ET Monday-Friday and force-closes all open positions"
    - "addPosition() allows botController.ts to hydrate the in-memory map on startup"
  artifacts:
    - path: "backend/src/services/positionMonitor.ts"
      provides: "5s polling exit loop + EOD cron + position hydration interface"
      exports:
        - "startPositionMonitor"
        - "addPosition"
        - "removePosition"
  key_links:
    - from: "backend/src/services/positionMonitor.ts setInterval"
      to: "backend/src/services/alpaca.ts getSnapshots"
      via: "getSnapshots([...openSymbols]) called every 5s"
      pattern: "getSnapshots"
    - from: "backend/src/services/positionMonitor.ts closePosition"
      to: "backend/prisma/schema.prisma BotTrade"
      via: "prisma.botTrade.update({ status: 'closed', exitReason, exitPrice, pnl })"
      pattern: "prisma.botTrade.update"
    - from: "backend/src/services/positionMonitor.ts scheduleEodForceClose"
      to: "node-cron"
      via: "cron.schedule('45 15 * * 1-5', handler, { timezone: 'America/New_York' })"
      pattern: "cron.schedule"
---

<objective>
Create `positionMonitor.ts` — the 5-second polling exit loop that enforces all exit conditions for open bot positions, plus the 3:45 PM ET EOD force-close cron job. This service is the sell-side counterpart to tradeExecutor.ts.

Purpose: Once the bot buys a position, something must watch it and exit when hard stop, profit target, time limit, or market-close triggers. This service is that watchdog.

Output: One new TypeScript file. Not wired into startup yet — that happens in Plan 03-04.
</objective>

<execution_context>
@C:/Users/Owner/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Owner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-trade-executor-and-position-monitor/CONTEXT.md
@.planning/phases/03-trade-executor-and-position-monitor/03-RESEARCH.md
@.planning/phases/03-trade-executor-and-position-monitor/03-01-SUMMARY.md

<interfaces>
<!-- botController.ts exports used: -->
```typescript
export function getAlpacaBaseUrl(): string;
export function getBotConfig(): BotConfigRecord;
// BotConfigRecord fields used:
//   .hardStopLossPct    (e.g. 7.0 = 7% below entry)
//   .profitTargetPct    (e.g. 10.0 = 10% above entry) — added in Plan 03-01
//   .maxHoldDurationSec (e.g. 300 = 5 minutes)
```

<!-- alpaca.ts getSnapshots export (used for polling): -->
```typescript
// from backend/src/services/alpaca.ts
interface TickerSnapshot {
  ticker: string;
  price: number;
  relativeVolume: number;
  // ...other fields
}
export async function getSnapshots(symbols: string[]): Promise<TickerSnapshot[]>;
// NOTE: ONE request for ALL symbols — do not call per-symbol in the poll loop
```

<!-- config.ts fields used: -->
```typescript
config.alpacaApiKey
config.alpacaApiSecret
```

<!-- Alpaca sell order (same pattern as paperTrader.ts but uses qty, not notional): -->
```typescript
// Sell orders use qty (number of shares), NOT notional
// Body: { symbol, qty: String(shares), side: 'sell', type: 'market', time_in_force: 'day' }
```

<!-- BotTrade Prisma model: -->
```prisma
model BotTrade {
  id             String    @id @default(cuid())
  symbol         String
  entryPrice     Float?
  exitPrice      Float?
  shares         Float?
  pnl            Float?
  catalystType   String?
  catalystTier   Int?
  exitReason     String?
  status         String    // "open" | "closed" | "missed"
  alpacaOrderId  String?
  entryAt        DateTime?
  exitAt         DateTime?
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt
}
```

<!-- paperTrader.ts reference (DO NOT MODIFY): -->
// The sold boolean guard pattern from paperTrader.ts prevents double-exits:
//   if (position.sold) return;
//   position.sold = true;  // set BEFORE any async sell
// The 5s setInterval pattern is identical to startTrailingStopMonitor() in paperTrader.ts
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create positionMonitor.ts — exit loop, sell logic, addPosition interface</name>
  <files>backend/src/services/positionMonitor.ts</files>
  <action>
Create `backend/src/services/positionMonitor.ts`.

**In-memory position map:**
```typescript
interface TrackedPosition {
  tradeId: string;      // BotTrade.id — primary key for DB updates
  symbol: string;
  entryPrice: number;
  entryAt: Date;
  peakPrice: number;    // tracked for future trailing stop (deferred per CONTEXT.md)
  shares: number;       // authoritative qty — updated after partial_fill
  catalystCategory: string;
  sold: boolean;        // race condition guard — set true BEFORE any sell
}

const openPositions = new Map<string, TrackedPosition>(); // key = tradeId
```

**Exit condition check function (called inside the poll loop):**
Check three exits in priority order (hard stop first, then profit target, then time):

```typescript
async function checkExitConditions(pos: TrackedPosition, currentPrice: number): Promise<void> {
  if (pos.sold) return;

  // Update peak for future trailing stop
  if (currentPrice > pos.peakPrice) pos.peakPrice = currentPrice;

  const cfg = getBotConfig();
  const pctChange = (currentPrice - pos.entryPrice) / pos.entryPrice * 100;
  const holdMinutes = (Date.now() - pos.entryAt.getTime()) / 60000;
  const maxHoldMinutes = cfg.maxHoldDurationSec / 60;

  // EXIT-01: Hard stop loss (stopLossPct is a positive number, e.g. 7 means -7%)
  if (pctChange <= -cfg.hardStopLossPct) {
    await closePosition(pos, currentPrice, 'hard_stop');
    return;
  }
  // EXIT-03: Profit target
  if (pctChange >= cfg.profitTargetPct) {
    await closePosition(pos, currentPrice, 'profit_target');
    return;
  }
  // EXIT-04: Max hold time
  if (holdMinutes >= maxHoldMinutes) {
    await closePosition(pos, currentPrice, 'time_exit');
    return;
  }
  // EXIT-02: Trailing stop — DEFERRED per CONTEXT.md ("May add trailing stop logic; defer to config too")
  // peakPrice is tracked above for when this is added
}
```

**closePosition() — sell logic with sold guard (CRITICAL race condition protection):**
```typescript
async function closePosition(pos: TrackedPosition, exitPrice: number | null, reason: string): Promise<void> {
  if (pos.sold) return;
  pos.sold = true;                           // set BEFORE any async operation
  openPositions.delete(pos.tradeId);         // remove from map immediately

  try {
    if (pos.shares > 0 && exitPrice !== null) {
      // Place market sell (use qty, not notional — selling shares we hold)
      const res = await fetch(`${getAlpacaBaseUrl()}/v2/orders`, {
        method: 'POST',
        headers: {
          'APCA-API-Key-ID': config.alpacaApiKey,
          'APCA-API-Secret-Key': config.alpacaApiSecret,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          symbol: pos.symbol,
          qty: String(pos.shares),
          side: 'sell',
          type: 'market',
          time_in_force: 'day',
        }),
      });
      if (!res.ok) {
        const text = await res.text();
        console.error(`[PositionMonitor] SELL failed for ${pos.symbol} (${res.status}): ${text}`);
        // Do NOT re-add to openPositions — the sold flag prevents re-entry
      } else {
        const order = await res.json() as { id: string };
        console.log(`[PositionMonitor] SELL placed (${reason}): ${pos.symbol} qty=${pos.shares} order=${order.id}`);
      }
    }

    // Calculate P&L
    const pnl = exitPrice != null ? (exitPrice - pos.entryPrice) * pos.shares : null;

    // Update BotTrade in DB
    await prisma.botTrade.update({
      where: { id: pos.tradeId },
      data: {
        status: 'closed',
        exitReason: reason,
        exitPrice: exitPrice ?? undefined,
        exitAt: new Date(),
        pnl: pnl ?? undefined,
      },
    });

    console.log(`[PositionMonitor] Position closed (${reason}): ${pos.symbol} pnl=${pnl?.toFixed(2) ?? 'N/A'}`);
  } catch (err) {
    // Never crash the monitor loop on sell failure
    console.error(`[PositionMonitor] closePosition error for ${pos.symbol}:`, err instanceof Error ? err.message : err);
  }
}
```

**5-second polling loop (EXIT-06):**
```typescript
const POLL_INTERVAL_MS = 5000;

setInterval(async () => {
  if (openPositions.size === 0) return;
  try {
    const symbols = [...new Set([...openPositions.values()].map(p => p.symbol))];
    const snapshots = await getSnapshots(symbols);
    for (const snap of snapshots) {
      const positionsForSymbol = [...openPositions.values()].filter(p => p.symbol === snap.ticker);
      for (const pos of positionsForSymbol) {
        await checkExitConditions(pos, snap.price);
      }
    }
  } catch (err) {
    console.error('[PositionMonitor] Poll error:', err instanceof Error ? err.message : err);
  }
}, POLL_INTERVAL_MS);
```

**EOD force-close cron (EXIT-05):**
```typescript
import cron from 'node-cron';

export function scheduleEodForceClose(): void {
  cron.schedule('45 15 * * 1-5', async () => {
    console.log('[PositionMonitor] EOD force-close at 3:45 PM ET');
    const openTrades = [...openPositions.values()];
    for (const pos of openTrades) {
      // Get current price for P&L calculation
      const snaps = await getSnapshots([pos.symbol]).catch(() => []);
      const currentPrice = snaps[0]?.price ?? null;
      await closePosition(pos, currentPrice, 'force_close_eod');
    }
  }, { timezone: 'America/New_York' });
  console.log('[PositionMonitor] EOD force-close cron scheduled (3:45 PM ET, Mon-Fri)');
}
```

**Exported public API:**
```typescript
export function startPositionMonitor(): void {
  scheduleEodForceClose();
  console.log('[PositionMonitor] Started — polling every 5s, EOD close at 3:45 PM ET');
}

// Called by botController.ts reconcilePositions() to hydrate in-memory state on startup
export function addPosition(pos: Omit<TrackedPosition, 'sold'>): void {
  openPositions.set(pos.tradeId, { ...pos, sold: false });
  console.log(`[PositionMonitor] Tracking position: ${pos.symbol} tradeId=${pos.tradeId}`);
}

// Called by tradeExecutor.ts after fill confirmation (Plan 03-04 wires this)
export function removePosition(tradeId: string): void {
  openPositions.delete(tradeId);
}
```

**IMPORTANT notes:**
- Position monitor continues running even when bot is paused (CONTEXT.md: pausing means no new entries, not abandoning exits)
- The setInterval runs at module load time — it is always active after the module is imported
- `scheduleEodForceClose()` is called once from `startPositionMonitor()`
- Do NOT import tradingWs.ts or tradeExecutor.ts — positionMonitor.ts is a leaf service
- The `sold` boolean must be checked at the TOP of both `checkExitConditions` and `closePosition`
  </action>
  <verify>
    <automated>cd C:/Projects/StockNews/backend && rtk tsc --noEmit 2>&1 | head -30</automated>
  </verify>
  <done>positionMonitor.ts compiles without TypeScript errors; exports startPositionMonitor, addPosition, removePosition; tsc --noEmit passes; grep confirms 'sold' boolean guard appears in closePosition and checkExitConditions</done>
</task>

</tasks>

<verification>
1. `cd C:/Projects/StockNews/backend && rtk tsc --noEmit` — zero errors
2. `grep -c "pos.sold" backend/src/services/positionMonitor.ts` — at least 2 occurrences (guard in both functions)
3. `grep "45 15 \* \* 1-5" backend/src/services/positionMonitor.ts` — must find the weekday-only cron pattern
4. `grep "America/New_York" backend/src/services/positionMonitor.ts` — must find timezone option
5. `grep "hardStopLossPct\|profitTargetPct\|maxHoldDurationSec" backend/src/services/positionMonitor.ts` — all three config fields referenced
</verification>

<success_criteria>
- positionMonitor.ts: TrackedPosition interface with sold guard; 5s setInterval poll loop using batch getSnapshots(); hard stop/profit target/time exit checks in priority order; closePosition() with sold guard set before async sell; EOD cron with timezone+weekday-only pattern; addPosition()/removePosition()/startPositionMonitor() exported
- Trailing stop NOT implemented (deferred per CONTEXT.md) but peakPrice tracked for future use
- tsc --noEmit: zero errors
- sell orders use qty (not notional) because we're selling shares we hold
</success_criteria>

<output>
After completion, create `.planning/phases/03-trade-executor-and-position-monitor/03-03-SUMMARY.md`
</output>
