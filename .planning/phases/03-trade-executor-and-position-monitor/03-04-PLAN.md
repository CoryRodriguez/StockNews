---
phase: 03-trade-executor-and-position-monitor
plan: "04"
type: execute
wave: 3
depends_on:
  - "03-02"
  - "03-03"
files_modified:
  - backend/src/services/botController.ts
  - backend/src/services/signalEngine.ts
  - backend/src/index.ts
autonomous: true
requirements:
  - EXEC-01
  - EXEC-06

must_haves:
  truths:
    - "signalEngine.ts no longer uses rejectReason='log-only' — fired signals call void executeTradeAsync() instead"
    - "botController.ts reconcilePositions() imports orphan Alpaca positions into BotTrade and calls addPosition() for each"
    - "botController.ts reconcilePositions() calls addPosition() for each existing open BotTrade to warm the position monitor on startup"
    - "index.ts calls startTradingWs() and startPositionMonitor() after initBot()"
    - "botController.ts switchMode() calls restartTradingWs() so the trading WebSocket reconnects to the correct URL after a mode change"
    - "BotConfig upsert create block in initBot() includes defaults for tradeSizeStars3/4/5 and profitTargetPct"
  artifacts:
    - path: "backend/src/services/signalEngine.ts"
      provides: "Fires executeTradeAsync on outcome=fired (replaces log-only)"
      contains: "executeTradeAsync"
    - path: "backend/src/services/botController.ts"
      provides: "reconcilePositions with orphan import + addPosition hydration; switchMode restarts tradingWs"
      contains: "addPosition"
    - path: "backend/src/index.ts"
      provides: "Startup wiring — startTradingWs + startPositionMonitor after initBot"
      contains: "startTradingWs"
  key_links:
    - from: "backend/src/services/signalEngine.ts (outcome: fired)"
      to: "backend/src/services/tradeExecutor.ts executeTradeAsync"
      via: "void executeTradeAsync(signal).catch(err => console.error(...))"
      pattern: "executeTradeAsync"
    - from: "backend/src/services/botController.ts reconcilePositions"
      to: "backend/src/services/positionMonitor.ts addPosition"
      via: "addPosition() called for each open BotTrade and each orphan"
      pattern: "addPosition"
    - from: "backend/src/index.ts server.listen callback"
      to: "backend/src/services/tradingWs.ts startTradingWs"
      via: "called after await initBot()"
      pattern: "startTradingWs"
---

<objective>
Wire the three new services into the existing codebase: (1) replace the signal engine's log-only placeholder with a real fire-and-forget executor call, (2) update reconcilePositions() in botController.ts to import orphan positions and hydrate the position monitor's in-memory map, (3) add startup calls to startTradingWs() and startPositionMonitor() in index.ts.

Purpose: Plans 03-01/02/03 built the components. This plan is the final integration — nothing fires until these wiring changes are made.

Output: Three existing files modified. After this plan, the bot is functionally complete for paper trading.
</objective>

<execution_context>
@C:/Users/Owner/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Owner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-trade-executor-and-position-monitor/CONTEXT.md
@.planning/phases/03-trade-executor-and-position-monitor/03-RESEARCH.md
@.planning/phases/03-trade-executor-and-position-monitor/03-02-SUMMARY.md
@.planning/phases/03-trade-executor-and-position-monitor/03-03-SUMMARY.md

<interfaces>
<!-- signalEngine.ts current fired path (Step 11, both tier 1-2 and AI-approved tier 3-4): -->
```typescript
// Current (log-only — Phase 2):
await writeSignalLog({
  // ...fields...
  outcome: "fired",
  rejectReason: "log-only",    // ← THIS GETS REPLACED
  aiProceed: true,             // or null for tier 1-2
  aiConfidence: aiResult?.confidence ?? null,
  // ...
});
// Phase 3: add void executeTradeAsync() call AFTER writeSignalLog()

// The aiResult.confidence at this point is: 'high' | 'medium' | 'low' for tier 3-4
// For tier 1-2 path, aiResult is null (no AI evaluation)
```

<!-- tradeExecutor.ts exports (from Plan 03-02): -->
```typescript
export interface TradeSignal {
  symbol: string;
  catalystCategory: string;
  catalystTier: number;
  aiConfidence: 'high' | 'medium' | 'low' | null;
  priceAtSignal: number;
}
export async function executeTradeAsync(signal: TradeSignal): Promise<void>;
export async function onFillEvent(update: { event: 'fill' | 'partial_fill'; orderId: string; filledQty: string; filledAvgPrice: string | null; symbol: string; }): Promise<void>;
export async function onRejectedEvent(update: { orderId: string; symbol: string; }): Promise<void>;
```

<!-- positionMonitor.ts exports (from Plan 03-03): -->
```typescript
export function startPositionMonitor(): void;
export function addPosition(pos: Omit<TrackedPosition, 'sold'>): void;
// TrackedPosition shape needed for addPosition():
// { tradeId, symbol, entryPrice, entryAt, peakPrice, shares, catalystCategory }
```

<!-- tradingWs.ts exports (from Plan 03-02): -->
```typescript
export function startTradingWs(): void;
export function restartTradingWs(): void;
```

<!-- botController.ts current reconcilePositions() — will be extended: -->
```typescript
// Current behavior: marks DB-open positions that are missing from Alpaca as 'missed'
// Phase 3 adds:
// 1. For Alpaca positions with NO BotTrade → create BotTrade + call addPosition()
// 2. For DB open positions still present in Alpaca → call addPosition() to warm monitor
```

<!-- botController.ts current switchMode() — will call restartTradingWs(): -->
```typescript
export async function switchMode(newMode: BotMode): Promise<void>
// Add: restartTradingWs() call after updating botConfig
// Import restartTradingWs from tradingWs.ts at top of file
```

<!-- index.ts current startup sequence in server.listen callback: -->
```typescript
await loadStrategiesFromDb();
await recomputeStrategies();
await initBot();             // ← add startTradingWs() + startPositionMonitor() AFTER this
setInterval(() => recomputeStrategies(), 60 * 60 * 1000);
```

<!-- initBot() BotConfig upsert create block (must add new fields): -->
```typescript
// Current create block in initBot() is missing tradeSizeStars3/4/5 and profitTargetPct
// These MUST be added so the singleton row is created with correct defaults on first run
create: {
  // ...existing fields...
  tradeSizeStars3: 50,     // ← ADD
  tradeSizeStars4: 75,     // ← ADD
  tradeSizeStars5: 100,    // ← ADD
  profitTargetPct: 10,     // ← ADD
},
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update signalEngine.ts — replace log-only with executeTradeAsync call</name>
  <files>backend/src/services/signalEngine.ts</files>
  <action>
In `signalEngine.ts`, make three changes:

**1. Add import at top of file:**
```typescript
import { executeTradeAsync } from './tradeExecutor';
```

**2. Update the tier 1-2 fired path (Step 11, `!needsAI` branch):**
After the `await writeSignalLog({ ..., outcome: "fired", rejectReason: "log-only", ... })` call, add:
```typescript
// Phase 3: fire trade executor asynchronously — never blocks news handler (EXEC-06)
void executeTradeAsync({
  symbol,
  catalystCategory: classification.category,
  catalystTier: classification.tier,
  aiConfidence: null,          // tier 1-2 has no AI eval
  priceAtSignal: snap.price,
}).catch((err) =>
  console.error('[SignalEngine] executeTradeAsync error:', err instanceof Error ? err.message : err)
);
```

Also change `rejectReason: "log-only"` to `rejectReason: null` in this writeSignalLog call. The signal is now actually fired, not just logged.

**3. Update the AI-approved tier 3-4 fired path (the `aiResult.proceed === true` branch):**
After the `await writeSignalLog({ ..., outcome: "fired", rejectReason: "log-only", ... })` call, add:
```typescript
void executeTradeAsync({
  symbol,
  catalystCategory: classification.category,
  catalystTier: classification.tier,
  aiConfidence: aiResult.confidence,
  priceAtSignal: snap.price,
}).catch((err) =>
  console.error('[SignalEngine] executeTradeAsync error:', err instanceof Error ? err.message : err)
);
```

Also change `rejectReason: "log-only"` to `rejectReason: null` in this writeSignalLog call.

DO NOT change any other part of the file. The signal evaluation gauntlet (steps 1-10) is unchanged. Only the two "fired" outcome branches at the bottom of Step 11 gain the executor call.

VERIFY: After the change, grep for `"log-only"` in signalEngine.ts — it must appear ZERO times.
  </action>
  <verify>
    <automated>cd C:/Projects/StockNews/backend && rtk tsc --noEmit 2>&1 | head -20 && grep -c "log-only" src/services/signalEngine.ts && echo "log-only count above should be 0"</automated>
  </verify>
  <done>signalEngine.ts imports executeTradeAsync; both fired branches call void executeTradeAsync().catch(); rejectReason is null (not "log-only") in both fired writeSignalLog calls; tsc --noEmit passes</done>
</task>

<task type="auto">
  <name>Task 2: Update botController.ts and index.ts — reconciliation, mode switch, startup wiring</name>
  <files>backend/src/services/botController.ts, backend/src/index.ts</files>
  <action>
Make four changes across two files:

**botController.ts change 1 — Add imports at top:**
```typescript
import { addPosition } from './positionMonitor';
import { restartTradingWs } from './tradingWs';
```

**botController.ts change 2 — Update reconcilePositions() for orphan import and startup hydration (CONTEXT.md):**

Replace the current `reconcilePositions()` function body. The new version must:

A. Fetch `GET /v2/positions` (same as current)
B. Build a `Map<string, AlpacaPositionFull>` from live positions (add `avg_entry_price`, `qty`, `symbol` to the parsed type)
C. For each open BotTrade in DB:
   - If NOT in liveSymbols → mark as `missed` (same as current)
   - If IS in liveSymbols → call `addPosition({ tradeId: trade.id, symbol: trade.symbol, entryPrice: trade.entryPrice ?? 0, entryAt: trade.entryAt ?? new Date(), peakPrice: trade.entryPrice ?? 0, shares: trade.shares ?? 0, catalystCategory: trade.catalystType ?? 'unknown' })`
D. For each live position NOT in DB (orphan import per CONTEXT.md):
   - Create a new BotTrade: `{ symbol: livePos.symbol, entryPrice: parseFloat(livePos.avg_entry_price), shares: parseFloat(livePos.qty), status: 'open', catalystType: 'unknown', catalystTier: null, alpacaOrderId: null, exitReason: null, entryAt: new Date() }`
   - Log warning: `[BotController] Orphan position imported: ${livePos.symbol} qty=${livePos.qty}`
   - Call `addPosition({ tradeId: newTrade.id, symbol: livePos.symbol, entryPrice: parseFloat(livePos.avg_entry_price), entryAt: new Date(), peakPrice: parseFloat(livePos.avg_entry_price), shares: parseFloat(livePos.qty), catalystCategory: 'unknown' })`
E. Keep the try/catch wrapper — reconcilePositions() must still be non-fatal

**botController.ts change 3 — Update initBot() upsert create block:**
Add the four new BotConfig fields to the `create:` block (the `update: {}` block stays empty):
```typescript
tradeSizeStars3: 50,
tradeSizeStars4: 75,
tradeSizeStars5: 100,
profitTargetPct: 10,
```

**botController.ts change 4 — Add restartTradingWs() to switchMode():**
At the end of `switchMode()` after updating botConfig (after the `prisma.botConfig.update` call), add:
```typescript
restartTradingWs();
```

**index.ts change — Add startTradingWs and startPositionMonitor to startup sequence:**
Add imports at top:
```typescript
import { startTradingWs } from './services/tradingWs';
import { startPositionMonitor } from './services/positionMonitor';
```

In the `server.listen` callback, AFTER `await initBot()` and BEFORE the `setInterval` for recomputeStrategies, add:
```typescript
startTradingWs();
startPositionMonitor();
```

The startup sequence in index.ts should now read:
```typescript
await loadStrategiesFromDb();
await recomputeStrategies();
await initBot();         // loads config, reconciles positions, hydrates positionMonitor
startTradingWs();        // connect to Alpaca trading stream
startPositionMonitor();  // start 5s poll loop + EOD cron
setInterval(() => recomputeStrategies(), 60 * 60 * 1000);
```
  </action>
  <verify>
    <automated>cd C:/Projects/StockNews/backend && rtk tsc --noEmit 2>&1 | head -30</automated>
  </verify>
  <done>botController.ts: reconcilePositions() handles orphan import + hydrates addPosition() for existing open trades; initBot() create block has four new fields; switchMode() calls restartTradingWs(). index.ts: imports and calls startTradingWs() and startPositionMonitor() after initBot(). tsc --noEmit passes with zero errors across all modified files.</done>
</task>

</tasks>

<verification>
1. `cd C:/Projects/StockNews/backend && rtk tsc --noEmit` — zero errors
2. `grep -c "log-only" backend/src/services/signalEngine.ts` — must output 0
3. `grep "executeTradeAsync" backend/src/services/signalEngine.ts` — must find two occurrences (one per fired branch)
4. `grep "addPosition\|restartTradingWs" backend/src/services/botController.ts` — must find both
5. `grep "startTradingWs\|startPositionMonitor" backend/src/index.ts` — must find both
6. `grep "tradeSizeStars3\|profitTargetPct" backend/src/services/botController.ts` — must find both in the create block
</verification>

<success_criteria>
- signalEngine.ts: zero occurrences of "log-only"; two void executeTradeAsync() calls with proper aiConfidence mapping
- botController.ts: reconcilePositions() calls addPosition() for all open DB positions and all orphan Alpaca positions; initBot() create block has all four new BotConfig fields; switchMode() calls restartTradingWs()
- index.ts: startTradingWs() and startPositionMonitor() called after initBot() in startup sequence
- tsc --noEmit: zero errors across all three modified files
</success_criteria>

<output>
After completion, create `.planning/phases/03-trade-executor-and-position-monitor/03-04-SUMMARY.md`
</output>
