---
phase: 04-risk-management-enforcement
plan: 02
type: execute
wave: 2
depends_on:
  - 04-01
files_modified:
  - backend/src/services/signalEngine.ts
  - backend/src/services/tradeExecutor.ts
autonomous: true
requirements:
  - RISK-02
  - RISK-03
  - RISK-05
must_haves:
  truths:
    - "When open positions >= maxConcurrentPositions, new signals are rejected with rejectReason='max-positions' in BotSignalLog"
    - "When bot already holds a symbol, a new signal for that symbol is rejected with rejectReason='already-holding' in BotSignalLog"
    - "In live mode, if Alpaca daytrade_count >= 3, the buy order is blocked and logged as a rejected BotTrade with exitReason='pdt_limit'"
    - "PDT check is skipped entirely in paper mode"
    - "tsc --noEmit passes with no errors"
  artifacts:
    - path: "backend/src/services/signalEngine.ts"
      provides: "RISK-02 and RISK-05 gates at steps 10.5-10.6 of the evaluation gauntlet"
      contains: "max-positions"
    - path: "backend/src/services/tradeExecutor.ts"
      provides: "PDT check function called before placeNotionalBuyOrder in live mode"
      contains: "pdt_limit"
  key_links:
    - from: "signalEngine.ts step 10.5"
      to: "positionMonitor.ts getOpenPositionCount()"
      via: "imported function call"
      pattern: "getOpenPositionCount"
    - from: "signalEngine.ts step 10.6"
      to: "positionMonitor.ts openPositions Map"
      via: "getOpenSymbols() or equivalent check"
      pattern: "already-holding"
    - from: "tradeExecutor.ts executeTradeAsync"
      to: "Alpaca GET /v2/account"
      via: "checkPdtLimit() async function"
      pattern: "daytrade_count"
---

<objective>
Add the three signal-layer and executor-layer risk gates: RISK-02 (max concurrent positions), RISK-05 (per-symbol concentration), and RISK-03 (PDT enforcement). Each gate rejects signals with a logged reason rather than silently dropping them.

Purpose: Without these gates, the bot could stack positions beyond user limits, double-enter symbols, or violate PDT rules in live mode — all of which erode the fast-entry/tight-exit risk philosophy.
Output: signalEngine.ts with steps 10.5-10.6 inserted; tradeExecutor.ts with checkPdtLimit() added before buy.
</objective>

<execution_context>
@C:/Users/Owner/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Owner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md

<interfaces>
<!-- Key contracts the executor needs. Extracted from codebase. -->

From backend/src/services/positionMonitor.ts (Plan 04-03 will add these exports — add import stubs now):
```typescript
// Export to add in positionMonitor.ts (Plan 04-03):
export function getOpenPositionCount(): number { return openPositions.size; }
export function getOpenSymbols(): Set<string> { return new Set([...openPositions.values()].map(p => p.symbol)); }
```
Note: Plan 04-02 (this plan) imports these from positionMonitor. Plan 04-03 adds the exports.
Since both run in Wave 2 in parallel, the executor must add stub exports to positionMonitor.ts in this plan
to avoid TypeScript errors — OR the executor can add the imports with a comment and run tsc only after
Plan 04-03 completes. Use the simpler approach: add a thin import wrapper and defer tsc to Plan 04-04.

From backend/src/services/signalEngine.ts (current evaluation gauntlet — insertion points):
```
Step 10: 5 Pillars check → last check before firing (ends with `const snap = snaps[0];`)
Step 11: Branch on tier — tier 1-2: fired; tier 3-4: AI evaluate
INSERT between step 10 and step 11:
  Step 10.5: RISK-02 — max concurrent positions check
  Step 10.6: RISK-05 — already-holding check
```

writeSignalLog() signature (existing helper in signalEngine.ts):
```typescript
async function writeSignalLog(
  data: Parameters<typeof prisma.botSignalLog.create>[0]["data"]
): Promise<void>
// Usage pattern (all fields must be provided):
await writeSignalLog({
  symbol,
  source: article.source,
  headline: article.title,
  catalystCategory: classification.category,
  catalystTier: classification.tier,
  outcome: "rejected",
  rejectReason: "max-positions",   // or "already-holding"
  failedPillar: null,
  aiProceed: null,
  aiConfidence: null,
  aiReasoning: null,
  winRateAtEval,                   // already computed above in step 9
  priceAtEval: snap.price,         // snap is already fetched in step 10
  relVolAtEval: snap.relativeVolume,
  articleCreatedAt: new Date(article.createdAt),
});
```

From backend/src/services/tradeExecutor.ts (PDT check insertion point):
```typescript
// executeTradeAsync() current step order:
// Step 1: getStarRating() — null = skip
// Step 2: hasOpenPosition() — true = silent skip (keep as safety net)
// Step 3: getNotional()
// Step 4: placeNotionalBuyOrder()   ← INSERT checkPdtLimit() BEFORE this

// INSERT: checkPdtLimit() function (async, returns boolean):
async function checkPdtLimit(): Promise<boolean> {
  const botCfg = getBotConfig();
  if (botCfg.mode !== 'live') return false; // paper mode: >$25k account, PDT doesn't apply
  try {
    const res = await fetch(`${getAlpacaBaseUrl()}/v2/account`, {
      headers: getAlpacaHeaders(),
    });
    if (!res.ok) {
      console.warn(`[TradeExecutor] PDT check: account fetch failed (${res.status}) — allowing trade`);
      return false; // fail open on API errors
    }
    const account = await res.json() as { daytrade_count: number };
    return account.daytrade_count >= 3;
  } catch (err) {
    console.warn('[TradeExecutor] PDT check error — allowing trade:', err);
    return false; // fail open
  }
}

// When PDT limit reached — write rejected BotTrade record:
await prisma.botTrade.create({
  data: {
    symbol,
    status: 'rejected',
    exitReason: 'pdt_limit',
    catalystType: catalystCategory,
    catalystTier,
    entryAt: new Date(),
  },
});
```

getAlpacaHeaders() is already defined in tradeExecutor.ts and returns the correct auth headers.
getAlpacaBaseUrl() is imported from botController.ts.
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add RISK-02 and RISK-05 gates to signalEngine.ts</name>
  <files>backend/src/services/signalEngine.ts</files>
  <action>
Add two new imports at the top of signalEngine.ts:
```typescript
import { getOpenPositionCount, getOpenSymbols } from './positionMonitor';
```
(Note: getOpenPositionCount and getOpenSymbols are added to positionMonitor.ts in Plan 04-03. Both plans run in Wave 2 — tsc is verified in Plan 04-04 after both complete.)

In the `evaluateBotSignal()` function, INSERT the following two new steps AFTER step 10 (the 5 Pillars check, which ends after `const snap = snaps[0];` and before the closing brace of the step 10 pillar checks) and BEFORE step 11 (the `const needsAI = classification.tier >= 3;` line):

```typescript
    // ── Step 10.5: Max concurrent positions check (RISK-02) ───────────────
    const openCount = getOpenPositionCount();
    if (openCount >= config.maxConcurrentPositions) {
      await writeSignalLog({
        symbol,
        source: article.source,
        headline: article.title,
        catalystCategory: classification.category,
        catalystTier: classification.tier,
        outcome: 'rejected',
        rejectReason: 'max-positions',
        failedPillar: null,
        aiProceed: null,
        aiConfidence: null,
        aiReasoning: null,
        winRateAtEval,
        priceAtEval: snap.price,
        relVolAtEval: snap.relativeVolume,
        articleCreatedAt: new Date(article.createdAt),
      });
      return;
    }

    // ── Step 10.6: Per-symbol concentration check (RISK-05) ───────────────
    // Moves the silent skip from tradeExecutor.ts step 2 into the signal engine
    // so the BotSignalLog has full article context (headline, source, catalystCategory).
    if (getOpenSymbols().has(symbol)) {
      await writeSignalLog({
        symbol,
        source: article.source,
        headline: article.title,
        catalystCategory: classification.category,
        catalystTier: classification.tier,
        outcome: 'rejected',
        rejectReason: 'already-holding',
        failedPillar: null,
        aiProceed: null,
        aiConfidence: null,
        aiReasoning: null,
        winRateAtEval,
        priceAtEval: snap.price,
        relVolAtEval: snap.relativeVolume,
        articleCreatedAt: new Date(article.createdAt),
      });
      return;
    }
```

The existing `hasOpenPosition()` guard in tradeExecutor.ts step 2 remains as a safety net (silent skip) but the upstream check in signalEngine.ts ensures the audit log is always written with article context.
  </action>
  <verify>grep -n "max-positions\|already-holding\|getOpenPositionCount\|getOpenSymbols" c:/Projects/StockNews/backend/src/services/signalEngine.ts</verify>
  <done>signalEngine.ts contains both new rejection reasons in the evaluation gauntlet; imports getOpenPositionCount and getOpenSymbols from positionMonitor</done>
</task>

<task type="auto">
  <name>Task 2: Add PDT enforcement to tradeExecutor.ts</name>
  <files>backend/src/services/tradeExecutor.ts</files>
  <action>
In backend/src/services/tradeExecutor.ts, add prisma import at the top if not already present (it already is imported as `import prisma from '../db/client';`).

Add the `checkPdtLimit()` helper function BEFORE `executeTradeAsync()`. Place it after the existing `placeNotionalBuyOrder()` function block:

```typescript
// ─── Helpers: PDT guard (RISK-03 — live mode only) ────────────────────────────

/**
 * Checks Alpaca account daytrade_count. Returns true if the next trade would
 * push the account to 4+ day trades in the 5-day window (PDT violation).
 *
 * Paper mode: always returns false (account is >$25k, PDT rule doesn't apply).
 * Fail open: any API error or non-200 response returns false (allow trade).
 * This prevents blocking all trades during Alpaca maintenance windows.
 */
async function checkPdtLimit(): Promise<boolean> {
  const botCfg = getBotConfig();
  if (botCfg.mode !== 'live') return false; // PDT only applies to live accounts under $25k

  try {
    const res = await fetch(`${getAlpacaBaseUrl()}/v2/account`, {
      headers: getAlpacaHeaders(),
    });
    if (!res.ok) {
      console.warn(`[TradeExecutor] PDT check: account fetch failed (${res.status}) — allowing trade`);
      return false;
    }
    const account = await res.json() as { daytrade_count: number };
    // daytrade_count >= 3 means placing this trade would be the 4th in the 5-day window
    return account.daytrade_count >= 3;
  } catch (err) {
    console.warn('[TradeExecutor] PDT check error — allowing trade:', err instanceof Error ? err.message : err);
    return false;
  }
}
```

In `executeTradeAsync()`, INSERT the PDT check AFTER step 3 (getNotional) and BEFORE step 4 (placeNotionalBuyOrder). Add as a new step 3.5:

```typescript
  // Step 3.5: PDT guard — live mode only (RISK-03)
  // Paper mode is >$25k intentionally — no PDT applies (per CONTEXT.md locked decision)
  if (await checkPdtLimit()) {
    console.warn(`[TradeExecutor] PDT limit reached for ${symbol} — blocked (live mode)`);
    await prisma.botTrade.create({
      data: {
        symbol,
        status: 'rejected',
        exitReason: 'pdt_limit',
        catalystType: catalystCategory,
        catalystTier,
        entryAt: new Date(),
      },
    });
    return;
  }
```
  </action>
  <verify>grep -n "checkPdtLimit\|pdt_limit\|daytrade_count" c:/Projects/StockNews/backend/src/services/tradeExecutor.ts</verify>
  <done>tradeExecutor.ts contains checkPdtLimit() function and the PDT guard step in executeTradeAsync(); pdt_limit rejection is written to BotTrade when triggered</done>
</task>

</tasks>

<verification>
```bash
# 1. RISK-02 gate present in signal engine
grep -n "max-positions\|getOpenPositionCount" c:/Projects/StockNews/backend/src/services/signalEngine.ts

# 2. RISK-05 gate present in signal engine
grep -n "already-holding\|getOpenSymbols" c:/Projects/StockNews/backend/src/services/signalEngine.ts

# 3. PDT guard present in trade executor
grep -n "checkPdtLimit\|pdt_limit\|daytrade_count" c:/Projects/StockNews/backend/src/services/tradeExecutor.ts

# 4. Insertion order is correct (steps 10.5 and 10.6 appear after step 10, before step 11)
grep -n "Step 10\|Step 11\|max-positions\|already-holding\|needsAI" c:/Projects/StockNews/backend/src/services/signalEngine.ts
```
</verification>

<success_criteria>
- signalEngine.ts has two new rejection gates (steps 10.5 and 10.6) between the 5-Pillars check and the tier branch
- Both gates write BotSignalLog with full article context (outcome='rejected', correct rejectReason)
- tradeExecutor.ts has checkPdtLimit() that returns false in paper mode and fails open on API errors
- PDT block writes a BotTrade record with status='rejected', exitReason='pdt_limit'
- No existing tests or logic broken
</success_criteria>

<output>
After completion, create `.planning/phases/04-risk-management-enforcement/04-02-SUMMARY.md` with:
- What was added to signalEngine.ts (step numbers, rejection reasons)
- What was added to tradeExecutor.ts (checkPdtLimit, pdt_limit record)
- Any edge cases noted
- Commit hash(es)
</output>
