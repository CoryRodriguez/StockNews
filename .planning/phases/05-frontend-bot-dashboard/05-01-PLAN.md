---
phase: 05-frontend-bot-dashboard
plan: "05-01"
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/src/routes/bot.ts
  - backend/src/services/botController.ts
  - backend/src/services/positionMonitor.ts
  - backend/src/services/signalEngine.ts
autonomous: true
requirements:
  - UI-01
  - UI-02
  - UI-03
  - UI-05
  - UI-06
  - UI-07

must_haves:
  truths:
    - "GET /api/bot/status response includes dayTradeCount field"
    - "GET /api/bot/config returns the current BotConfig singleton"
    - "PATCH /api/bot/config persists partial updates to DB (strips id and updatedAt)"
    - "GET /api/bot/positions returns BotTrade rows with status='open'"
    - "GET /api/bot/trades returns last 100 BotTrade rows with status != 'open'"
    - "GET /api/bot/signals returns last 100 BotSignalLog rows with outcome='rejected'"
    - "botController.setBotState() broadcasts bot_status_update on the 'bot' WS channel"
    - "positionMonitor.closePosition() broadcasts bot_trade_closed on the 'bot' WS channel"
    - "signalEngine.evaluateBotSignal() broadcasts bot_signal_evaluated for rejected outcomes"
  artifacts:
    - backend/src/routes/bot.ts
  key_links:
    - "broadcast('bot', ...) in clientHub.ts is the WS delivery mechanism for all three push types"
    - "updateConfig() in botController.ts already handles Partial<Omit<BotConfigRecord, 'id' | 'updatedAt'>>"
---

<objective>
Add the four new REST endpoints and three WebSocket broadcast calls that the frontend Bot Panel consumes.

Purpose: The frontend BotPanel needs data it can fetch on mount and live updates via WebSocket. All backend plumbing must exist before the frontend is built (Plan 05-04). This plan is Wave 1 and can execute in parallel with Plan 05-02.

Output:
- `backend/src/routes/bot.ts` — extended with /config GET+PATCH, /positions, /trades, /signals; /status extended with dayTradeCount
- `backend/src/services/botController.ts` — setBotState() calls broadcast("bot", bot_status_update)
- `backend/src/services/positionMonitor.ts` — closePosition() calls broadcast("bot", bot_trade_closed)
- `backend/src/services/signalEngine.ts` — broadcast("bot", bot_signal_evaluated) for rejected outcomes
</objective>

<execution_context>
@C:/Users/Owner/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Owner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/phases/05-frontend-bot-dashboard/05-CONTEXT.md
@.planning/phases/05-frontend-bot-dashboard/05-RESEARCH.md

<interfaces>
<!-- Key types and contracts the executor needs. -->

From backend/src/routes/bot.ts (existing routes — add to this file):
```typescript
import { Router } from 'express';
import prisma from '../db/client';
import { requireAuth } from '../middleware/auth';
import { getBotState, setBotState, getBotConfig, isMarketOpen, type BotState } from '../services/botController';
// Also import: updateConfig from botController

const router = Router();
// Existing: POST /start, /pause, /resume, /stop, GET /status
export default router;
```

From backend/src/services/botController.ts (exports used here):
```typescript
export interface BotConfigRecord {
  id: string; enabled: boolean; state: string; mode: string;
  positionSizeUsd: number; confidenceMultiplierHigh: number;
  confidenceMultiplierMed: number; confidenceMultiplierLow: number;
  maxConcurrentPositions: number; dailyLossLimitUsd: number;
  minWinRate: number; hardStopLossPct: number; maxHoldDurationSec: number;
  enabledCatalystTiers: string; maxFloatShares: number; maxSharePrice: number;
  minRelativeVolume: number; tradeSizeStars3: number; tradeSizeStars4: number;
  tradeSizeStars5: number; profitTargetPct: number; trailingStopPct: number;
  trailingStopDollar: number; updatedAt: Date;
}
export function getBotState(): BotState;
export function getBotConfig(): BotConfigRecord;
export async function setBotState(newState: BotState): Promise<void>;
export async function updateConfig(patch: Partial<Omit<BotConfigRecord, 'id' | 'updatedAt'>>): Promise<BotConfigRecord>;
```

From backend/src/ws/clientHub.ts:
```typescript
export function broadcast(channel: string, payload: object): void;
// Delivers message to all authenticated clients subscribed to `channel`
// Usage: broadcast("bot", { type: "bot_status_update", status: { state, mode, ... } })
```

From backend/src/services/positionMonitor.ts (relevant section):
```typescript
// closePosition() is called internally to close a position — add broadcast AFTER DB update
async function closePosition(pos: TrackedPosition, exitReason: string): Promise<void>
```

From backend/src/services/signalEngine.ts (relevant section):
```typescript
// writeSignalLog() writes BotSignalLog — add broadcast AFTER the write for rejected outcomes
// OR: add broadcast at the end of evaluateBotSignal() when outcome==="rejected"
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend bot.ts with four new REST endpoints and dayTradeCount in /status</name>
  <files>backend/src/routes/bot.ts</files>
  <action>
Open `backend/src/routes/bot.ts`. Make these changes:

1. **Add `updateConfig` to the import from `../services/botController`.**

2. **Extend GET /status** — add `dayTradeCount` field to the response. The current query already fetches `dailyStats` from `prisma.botDailyStats.findFirst`. Add `dayTradeCount: dailyStats?.dayTradeCount ?? 0` to the `res.json({...})` object alongside the existing fields.

3. **Add GET /config** after the existing /status route:
```typescript
router.get('/config', requireAuth, (_req, res) => {
  try {
    const cfg = getBotConfig();
    res.json(cfg);
  } catch (err) {
    console.error('[BotRoute] /config GET error:', err);
    res.status(500).json({ error: 'Failed to load bot config' });
  }
});
```

4. **Add PATCH /config** — strip `id` and `updatedAt` before calling `updateConfig()`, with lightweight validation:
```typescript
router.patch('/config', requireAuth, async (req, res) => {
  try {
    const { id: _id, updatedAt: _ts, ...patch } = req.body as Record<string, unknown>;
    // Lightweight validation
    if (patch.positionSizeUsd !== undefined && (patch.positionSizeUsd as number) <= 0) {
      res.status(400).json({ error: 'positionSizeUsd must be > 0' });
      return;
    }
    if (patch.minWinRate !== undefined) {
      const wr = patch.minWinRate as number;
      if (wr < 0 || wr > 1) { res.status(400).json({ error: 'minWinRate must be 0–1' }); return; }
    }
    const updated = await updateConfig(patch as Parameters<typeof updateConfig>[0]);
    res.json(updated);
  } catch (err) {
    console.error('[BotRoute] /config PATCH error:', err);
    res.status(500).json({ error: 'Failed to update bot config' });
  }
});
```

5. **Add GET /positions** — open bot trades ordered newest first:
```typescript
router.get('/positions', requireAuth, async (_req, res) => {
  try {
    const positions = await prisma.botTrade.findMany({
      where: { status: 'open' },
      orderBy: { entryAt: 'desc' },
    });
    res.json(positions);
  } catch (err) {
    console.error('[BotRoute] /positions error:', err);
    res.status(500).json({ error: 'Failed to load positions' });
  }
});
```

6. **Add GET /trades** — completed bot trades (last 100, newest first):
```typescript
router.get('/trades', requireAuth, async (_req, res) => {
  try {
    const trades = await prisma.botTrade.findMany({
      where: { status: { not: 'open' } },
      orderBy: { exitAt: 'desc' },
      take: 100,
    });
    res.json(trades);
  } catch (err) {
    console.error('[BotRoute] /trades error:', err);
    res.status(500).json({ error: 'Failed to load bot trades' });
  }
});
```

7. **Add GET /signals** — last 100 rejected signals with selected fields:
```typescript
router.get('/signals', requireAuth, async (_req, res) => {
  try {
    const signals = await prisma.botSignalLog.findMany({
      where: { outcome: 'rejected' },
      orderBy: { evaluatedAt: 'desc' },
      take: 100,
      select: {
        id: true,
        symbol: true,
        catalystCategory: true,
        catalystTier: true,
        rejectReason: true,
        evaluatedAt: true,
        headline: true,
        source: true,
      },
    });
    res.json(signals);
  } catch (err) {
    console.error('[BotRoute] /signals error:', err);
    res.status(500).json({ error: 'Failed to load bot signals' });
  }
});
```
  </action>
  <verify>
    <automated>cd C:/Projects/StockNews/backend && npx tsc --noEmit 2>&1 | head -30</automated>
  </verify>
  <done>tsc --noEmit passes with no errors. GET /status response shape includes dayTradeCount. Five new route handlers exist in bot.ts.</done>
</task>

<task type="auto">
  <name>Task 2: Wire three WebSocket broadcasts into backend services</name>
  <files>backend/src/services/botController.ts, backend/src/services/positionMonitor.ts, backend/src/services/signalEngine.ts</files>
  <action>
Add `broadcast("bot", ...)` calls at three points. All use `import { broadcast } from '../ws/clientHub';` (adjust relative path as needed per file).

**A. botController.ts — setBotState() broadcasts bot_status_update**

After the `await prisma.botConfig.update(...)` line in `setBotState()`, add:
```typescript
import { broadcast } from '../ws/clientHub';

// Inside setBotState(), after the prisma update:
broadcast('bot', {
  type: 'bot_status_update',
  status: {
    state: newState,
    mode: botConfig?.mode ?? 'paper',
    openPositionCount: 0,  // frontend will reconcile with /positions
    todayRealizedPnl: 0,
    todayTradeCount: 0,
    dayTradeCount: 0,
    marketOpen: isMarketOpen(),
  },
});
```
Note: The status broadcast intentionally sends a lightweight snapshot. The full status (with P&L, dayTradeCount) requires an async DB query; setBotState is sync after the prisma update. The frontend hydrates full status on mount — this broadcast is for state-change notification only. Keep it simple.

**B. positionMonitor.ts — closePosition() broadcasts bot_trade_closed**

In `closePosition()`, after the `await prisma.botTrade.update(...)` call that sets exitPrice/exitAt/pnl/status, add:
```typescript
import { broadcast } from '../ws/clientHub';

// After DB update in closePosition():
const pnl = (currentPrice - pos.entryPrice) * pos.shares;
broadcast('bot', {
  type: 'bot_trade_closed',
  trade: {
    id: pos.tradeId,
    symbol: pos.symbol,
    entryPrice: pos.entryPrice,
    exitPrice: currentPrice,
    shares: pos.shares,
    pnl,
    catalystType: pos.catalystCategory,
    exitReason,
    entryAt: pos.entryAt.toISOString(),
    exitAt: new Date().toISOString(),
  },
});
```
Important: `closePosition` receives `currentPrice` as a parameter. Use `pos.entryPrice`, `pos.shares`, `pos.catalystCategory` from the `TrackedPosition` struct. The `pnl` calculation here is for the broadcast only — the DB update already computes the authoritative pnl. Check the existing signature of `closePosition` in positionMonitor.ts to confirm parameter names before editing.

**C. signalEngine.ts — broadcast bot_signal_evaluated for rejected outcomes**

Find the `evaluateBotSignal` function (or `writeSignalLog` helper if it exists). After any `prisma.botSignalLog.create(...)` call where `outcome === 'rejected'`, add a broadcast. The cleanest approach: add a helper at the end of `evaluateBotSignal()` before it returns, checking the outcome:

```typescript
import { broadcast } from '../ws/clientHub';

// At the point where outcome is determined as 'rejected' and written to DB:
broadcast('bot', {
  type: 'bot_signal_evaluated',
  signal: {
    id: logRecord.id,           // the created BotSignalLog.id
    symbol: article.ticker,
    catalystCategory: catalystCategory ?? null,
    catalystTier: catalystTier ?? null,
    rejectReason,
    evaluatedAt: new Date().toISOString(),
  },
});
```

Read the actual signalEngine.ts code before editing. The broadcast should fire ONLY when `outcome === 'rejected'` — not for 'fired' or 'skipped' outcomes. Add the import at the top of the file if it's not already there.

After all three edits, run tsc --noEmit to confirm no type errors.
  </action>
  <verify>
    <automated>cd C:/Projects/StockNews/backend && npx tsc --noEmit 2>&1 | head -30</automated>
  </verify>
  <done>tsc --noEmit passes. broadcast('bot', ...) calls exist in setBotState (botController.ts), closePosition (positionMonitor.ts), and the rejected-outcome path of evaluateBotSignal (signalEngine.ts). Import of broadcast from clientHub is present in all three files.</done>
</task>

</tasks>

<verification>
Run after both tasks complete:
```bash
cd C:/Projects/StockNews/backend && npx tsc --noEmit 2>&1 | head -20
```
Expected: no TypeScript errors.

Spot-check route additions:
```bash
grep -n "router\." C:/Projects/StockNews/backend/src/routes/bot.ts
```
Expected: 10+ router.* lines (start, pause, resume, stop, status, config GET, config PATCH, positions, trades, signals).

Spot-check broadcast wiring:
```bash
grep -n "broadcast" C:/Projects/StockNews/backend/src/services/botController.ts C:/Projects/StockNews/backend/src/services/positionMonitor.ts C:/Projects/StockNews/backend/src/services/signalEngine.ts
```
Expected: at least one broadcast call in each file.
</verification>

<success_criteria>
- `npx tsc --noEmit` passes with zero errors in the backend
- 5 new route handlers in bot.ts (config GET, config PATCH, positions, trades, signals)
- GET /status response shape includes `dayTradeCount`
- `broadcast('bot', ...)` exists in botController, positionMonitor, and signalEngine
- No circular import issues (clientHub does not import from botController/positionMonitor/signalEngine)
</success_criteria>

<output>
After completion, create `.planning/phases/05-frontend-bot-dashboard/05-01-SUMMARY.md` using the summary template.
</output>
