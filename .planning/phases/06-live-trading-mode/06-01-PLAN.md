---
phase: 06-live-trading-mode
plan: "06-01"
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/src/services/goLiveGate.ts
  - backend/src/routes/bot.ts
autonomous: true
requirements:
  - LIVE-01
  - LIVE-02
  - LIVE-03

must_haves:
  truths:
    - "goLiveGate.ts exports evaluateGoLiveGate() that queries BotTrade and BotDailyStats"
    - "GoLiveGate interface exposes tradeCount, winRate, cleanDays plus *Met booleans and passed"
    - "POST /api/bot/mode route exists in bot.ts and calls switchMode()"
    - "POST /api/bot/mode rejects paper→live switch when gate is not satisfied (403)"
    - "POST /api/bot/mode allows live→paper switch without gate check"
    - "GET /api/bot/gate route exists and returns GoLiveGate response"
    - "switchMode() open-position guard is still in place (defense in depth)"
    - "Backend tsc --noEmit passes with zero errors"
  artifacts:
    - backend/src/services/goLiveGate.ts
    - backend/src/routes/bot.ts
  key_links:
    - "switchMode() in botController.ts already blocks on open positions — route adds gate check on top"
    - "All trade execution code already uses getAlpacaBaseUrl() — live mode is a URL switch only"
---

<objective>
Create the go-live gate service and wire the POST /api/bot/mode and GET /api/bot/gate routes into bot.ts.

Purpose: LIVE-01 is already code-complete at the infrastructure level (getAlpacaBaseUrl() and switchMode() exist). This plan exposes live mode switching safely: the gate service enforces the 30-trade / 40% win-rate / 5-clean-days criteria before allowing a paper→live transition. The UI built in Plan 06-02 depends on both routes.

Output:
- `backend/src/services/goLiveGate.ts` — evaluateGoLiveGate() + GoLiveGate interface
- `backend/src/routes/bot.ts` — POST /mode and GET /gate appended
</objective>

<execution_context>
@C:/Users/Owner/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Owner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/phases/06-live-trading-mode/06-RESEARCH.md

<interfaces>
<!-- Key contracts the executor needs. Extracted from codebase. -->

From backend/src/services/botController.ts (exports used here):
```typescript
export type BotMode = 'paper' | 'live';

// Already blocks if open positions exist — no code change needed
export async function switchMode(newMode: BotMode): Promise<void>;

// Already wired to return config.alpacaLiveUrl when mode='live'
export function getAlpacaBaseUrl(): string;
```

From backend/src/routes/bot.ts (existing routes — append to this file):
```typescript
import { Router } from 'express';
import { requireAuth } from '../middleware/auth';
import { getBotState, setBotState, getBotConfig, isMarketOpen, updateConfig, type BotState } from '../services/botController';
// switchMode is imported from botController — must add to import
// evaluateGoLiveGate must be imported from ../services/goLiveGate

const router = Router();
// Existing routes: POST /start, /pause, /resume, /stop
// GET /status, /config, /positions, /trades, /signals
// PATCH /config
export default router;
```

From backend/prisma/schema.prisma (query targets):
- BotTrade: { id, status ('open'|'closed'|'missed'|'rejected'), pnl (Float?) }
  — BotTrade has NO mode field — all existing closed trades are paper trades by definition
- BotDailyStats: { id, date (String YYYY-MM-DD ET), tradeCount (Int), ... }

From backend/src/db/client.ts:
```typescript
// prisma is the default export — import as:
import prisma from '../db/client';
```
</interfaces>
</context>

<tasks>

<task type="auto" tdd="true">
  <name>Task 1: Create goLiveGate.ts service with evaluateGoLiveGate()</name>
  <files>backend/src/services/goLiveGate.ts</files>
  <behavior>
    - evaluateGoLiveGate() returns passed=true only when ALL three sub-checks pass
    - tradeCountMet = (count of BotTrade rows where status='closed') >= 30
    - winRateMet = (winners / tradeCount) >= 0.40, where winner is pnl > 0; returns 0 when tradeCount=0
    - cleanDaysMet = countConsecutiveBusinessDays(recentDays) >= 5
    - cleanDays = count of consecutive business days from the most recent BotDailyStats rows where tradeCount > 0
    - Business day adjacency: Mon through Thu expects diff=1 calendar day to previous; Mon expects diff=3 (previous was Fri)
    - Dates from BotDailyStats are YYYY-MM-DD strings in ET timezone
    - If fewer than 5 BotDailyStats rows exist with tradeCount > 0, cleanDays < 5 and cleanDaysMet = false
    - blockingReason = first failing check's human-readable message; null when passed=true
    - All three sub-checks failing returns tradeCount blocking reason (checked first)
  </behavior>
  <action>
Create `backend/src/services/goLiveGate.ts` with this exact implementation:

```typescript
import prisma from '../db/client';

export interface GoLiveGate {
  passed: boolean;
  tradeCount: number;       // completed paper trades (all status='closed' BotTrade rows)
  tradeCountMet: boolean;   // >= 30
  winRate: number;          // 0.0–1.0
  winRateMet: boolean;      // >= 0.40
  cleanDays: number;        // consecutive clean trading days found
  cleanDaysMet: boolean;    // >= 5
  blockingReason: string | null;
}

const GATE_MIN_TRADES = 30;
const GATE_MIN_WIN_RATE = 0.40;
const GATE_MIN_CLEAN_DAYS = 5;

export async function evaluateGoLiveGate(): Promise<GoLiveGate> {
  // Sub-check 1 & 2: trade count + win rate
  // Note: BotTrade has no 'mode' field — all status='closed' rows are paper trades
  // by definition (live mode has never been active before gate first passes)
  const allClosed = await prisma.botTrade.findMany({
    where: { status: 'closed' },
    select: { pnl: true },
  });
  const tradeCount = allClosed.length;
  const tradeCountMet = tradeCount >= GATE_MIN_TRADES;

  const winners = allClosed.filter((t) => (t.pnl ?? 0) > 0).length;
  const winRate = tradeCount > 0 ? winners / tradeCount : 0;
  const winRateMet = winRate >= GATE_MIN_WIN_RATE;

  // Sub-check 3: consecutive clean trading days
  // "Clean day" = BotDailyStats row where tradeCount > 0
  // (server was running and executed trades; crash days likely have missing rows)
  const recentDays = await prisma.botDailyStats.findMany({
    where: { tradeCount: { gt: 0 } },
    orderBy: { date: 'desc' },
    take: 10, // fetch extra to find 5 consecutive
  });
  const cleanDays = countConsecutiveBusinessDays(recentDays.map((d) => d.date));
  const cleanDaysMet = cleanDays >= GATE_MIN_CLEAN_DAYS;

  const passed = tradeCountMet && winRateMet && cleanDaysMet;
  let blockingReason: string | null = null;
  if (!tradeCountMet) {
    blockingReason = `Need ${GATE_MIN_TRADES - tradeCount} more completed trades (have ${tradeCount})`;
  } else if (!winRateMet) {
    blockingReason = `Win rate ${(winRate * 100).toFixed(1)}% below 40% minimum`;
  } else if (!cleanDaysMet) {
    blockingReason = `Only ${cleanDays} of 5 required clean trading days`;
  }

  return {
    passed,
    tradeCount,
    tradeCountMet,
    winRate,
    winRateMet,
    cleanDays,
    cleanDaysMet,
    blockingReason,
  };
}

/**
 * Counts how many consecutive business days (Mon–Fri) appear at the start
 * of sortedDatesDesc (most-recent first). Stops counting at the first gap.
 *
 * Business day adjacency:
 *   - Mon → its predecessor was Fri: expect 3 calendar days gap
 *   - Tue–Fri → predecessor was the day before: expect 1 calendar day gap
 */
function countConsecutiveBusinessDays(sortedDatesDesc: string[]): number {
  if (sortedDatesDesc.length === 0) return 0;

  let count = 1;
  for (let i = 0; i < sortedDatesDesc.length - 1; i++) {
    // Use T12:00:00Z to avoid DST boundary issues when converting to Date
    const curr = new Date(sortedDatesDesc[i] + 'T12:00:00Z');
    const prev = new Date(sortedDatesDesc[i + 1] + 'T12:00:00Z');
    const diffDays = Math.round(
      (curr.getTime() - prev.getTime()) / (1000 * 60 * 60 * 24)
    );
    const currDayOfWeek = curr.getUTCDay(); // 0=Sun, 1=Mon, ..., 5=Fri
    // Monday (1): previous business day was Friday — 3 calendar days ago
    const expectedDiff = currDayOfWeek === 1 ? 3 : 1;
    if (diffDays !== expectedDiff) break;
    count++;
    if (count >= GATE_MIN_CLEAN_DAYS) break;
  }
  return count;
}
```

After writing, run tsc --noEmit to confirm no errors.
  </action>
  <verify>
    <automated>cd C:/Projects/StockNews/backend && npx tsc --noEmit 2>&1 | head -20</automated>
  </verify>
  <done>goLiveGate.ts exists, exports GoLiveGate interface and evaluateGoLiveGate() async function. tsc --noEmit passes with zero errors.</done>
</task>

<task type="auto">
  <name>Task 2: Add POST /mode and GET /gate routes to bot.ts</name>
  <files>backend/src/routes/bot.ts</files>
  <action>
Open `backend/src/routes/bot.ts`. Make two additions:

**1. Extend the imports at the top of the file:**

Add `switchMode` to the existing botController import:
```typescript
import {
  getBotState,
  setBotState,
  getBotConfig,
  isMarketOpen,
  updateConfig,
  switchMode,       // ADD THIS
  type BotState,
} from '../services/botController';
```

Add a new import for the gate service after the botController import:
```typescript
import { evaluateGoLiveGate } from '../services/goLiveGate';
```

**2. Append two new routes before the `export default router;` line:**

```typescript
// ─── POST /mode ───────────────────────────────────────────────────────────────
// Switches bot between paper and live mode.
// paper→live requires go-live gate to be satisfied (LIVE-03).
// Gate check is server-side — never trust client's gate assertion.
// live→paper does NOT require gate re-check.
// Both directions require no open positions (enforced by switchMode() service layer).
router.post('/mode', requireAuth, async (req, res) => {
  const { mode } = req.body as { mode: string };
  if (mode !== 'paper' && mode !== 'live') {
    res.status(400).json({ error: 'mode must be "paper" or "live"' });
    return;
  }
  // Gate check is only required when switching TO live
  if (mode === 'live') {
    try {
      const gate = await evaluateGoLiveGate();
      if (!gate.passed) {
        res.status(403).json({
          error: gate.blockingReason ?? 'Go-live gate not satisfied',
          gate,
        });
        return;
      }
    } catch (err) {
      console.error('[BotRoute] /mode gate evaluation error:', err);
      res.status(500).json({ error: 'Failed to evaluate go-live gate' });
      return;
    }
  }
  try {
    await switchMode(mode as 'paper' | 'live');
    // Frontend re-fetches GET /status after a successful switch to update the mode badge
    res.json({ mode });
  } catch (err) {
    // switchMode throws if positions are open — surface as 400
    const message = err instanceof Error ? err.message : 'Mode switch failed';
    res.status(400).json({ error: message });
  }
});

// ─── GET /gate ─────────────────────────────────────────────────────────────────
// Returns the current go-live gate status for the UI to display.
// Used by BotPanel to show gate progress before the user attempts to switch to live.
router.get('/gate', requireAuth, async (_req, res) => {
  try {
    const gate = await evaluateGoLiveGate();
    res.json(gate);
  } catch (err) {
    console.error('[BotRoute] /gate error:', err);
    res.status(500).json({ error: 'Failed to evaluate go-live gate' });
  }
});
```

After editing, run tsc --noEmit to confirm zero errors.
  </action>
  <verify>
    <automated>cd C:/Projects/StockNews/backend && npx tsc --noEmit 2>&1 | head -20 && grep -n "router.post('/mode'\|router.get('/gate'\|evaluateGoLiveGate\|switchMode" C:/Projects/StockNews/backend/src/routes/bot.ts</automated>
  </verify>
  <done>POST /mode and GET /gate routes exist in bot.ts. switchMode and evaluateGoLiveGate are imported. tsc --noEmit passes with zero errors.</done>
</task>

</tasks>

<verification>
Run after both tasks complete:
```bash
cd C:/Projects/StockNews/backend && npx tsc --noEmit 2>&1 | head -20
```
Expected: no TypeScript errors.

Confirm route additions:
```bash
grep -n "router\." C:/Projects/StockNews/backend/src/routes/bot.ts
```
Expected: includes `router.post('/mode'` and `router.get('/gate'`.

Confirm gate service:
```bash
test -f C:/Projects/StockNews/backend/src/services/goLiveGate.ts && echo "EXISTS" || echo "MISSING"
grep -n "export" C:/Projects/StockNews/backend/src/services/goLiveGate.ts
```
Expected: file exists, exports GoLiveGate and evaluateGoLiveGate.
</verification>

<success_criteria>
- goLiveGate.ts exists and exports GoLiveGate interface + evaluateGoLiveGate() function
- POST /api/bot/mode route exists — requires gate for paper→live, skips gate for live→paper
- GET /api/bot/gate route exists — returns GoLiveGate JSON
- switchMode() open-position guard remains intact (no changes to botController.ts)
- Backend tsc --noEmit passes with zero errors
- No new npm dependencies added (zero package.json changes)
</success_criteria>

<output>
After completion, create `.planning/phases/06-live-trading-mode/06-01-SUMMARY.md` using the summary template.
</output>
