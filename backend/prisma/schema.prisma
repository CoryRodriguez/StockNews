datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "linux-musl-openssl-3.0.x"]
}

model User {
  id        String   @id @default(cuid())
  password  String
  createdAt DateTime @default(now())
}

model Watchlist {
  id        String   @id @default(cuid())
  name      String
  tickers   String[]
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Layout {
  id        String   @id @default(cuid())
  name      String
  panels    Json
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model PaperTrade {
  id           String          @id @default(cuid())
  ticker       String
  qty          Int
  buyOrderId   String?
  buyPrice     Float?
  buyStatus    String          // "pending" | "filled" | "error"
  sellOrderId  String?
  sellPrice    Float?
  sellStatus   String          // "awaiting" | "pending" | "filled" | "error"
  catalyst     String          // News headline that triggered the trade
  catalystType String          // "tier1" | "tier2" | "tier3" | "tier4" | "other"
  scannerId    String?         // Which scanner the ticker was on
  pnl          Float?          // Realized P&L after sell fills
  analytics    TradeAnalytics?
  createdAt    DateTime        @default(now())
  updatedAt    DateTime        @updatedAt
}

// ── Trade Analytics: rich data layer for strategy optimization ─────────────

model TradeAnalytics {
  id                String   @id @default(cuid())
  paperTradeId      String   @unique
  paperTrade        PaperTrade @relation(fields: [paperTradeId], references: [id])

  // News metadata
  newsHeadline      String
  newsBody          String   @db.Text
  newsSource        String   @default("rtpr")
  catalystCategory  String   // Granular: FDA_APPROVAL, MA_ACQUISITION, EARNINGS_BEAT, etc.
  catalystTier      Int      // 1-4

  // Timestamps
  newsPublishedAt   DateTime
  newsDetectedAt    DateTime
  tradeEnteredAt    DateTime

  // Entry conditions
  entryPrice        Float
  entryVolume       Int
  avgVolume30d      Float
  relativeVolume    Float

  // Market context (nullable — filled by enrichment when available)
  marketCap         Float?
  floatShares       Float?
  sector            String?
  isPreMarket       Boolean  @default(false)

  // VWAP context at entry: (entryPrice - sessionVwap) / sessionVwap * 100
  // Positive = extended above VWAP (reversion risk); negative = below VWAP
  entryVwapDev      Float?

  // Computed post-trade
  peakPrice         Float?
  peakTimeOffsetSec Int?     // seconds after entry when peak occurred
  troughAfterPeak   Float?
  maxDrawdownPct    Float?   // (peak - trough) / peak * 100

  // Hold time outcome
  actualHoldSec     Int?     // how long we actually held
  exitPrice         Float?
  returnPct         Float?   // (exitPrice - entryPrice) / entryPrice * 100

  // Price snapshots at intervals
  priceSnapshots    PriceSnapshot[]

  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
}

model PriceSnapshot {
  id                String         @id @default(cuid())
  tradeAnalyticsId  String
  tradeAnalytics    TradeAnalytics @relation(fields: [tradeAnalyticsId], references: [id])

  offsetSeconds     Int            // 15, 30, 60, 120, 300, 600, 900, 1800, 3600, 7200, -1 (EOD)
  price             Float
  volume            Int            // cumulative volume at capture time
  returnPct         Float          // (price - entryPrice) / entryPrice * 100
  vwapDev           Float?         // (price - sessionVwap) / sessionVwap * 100 at capture time
  capturedAt        DateTime       @default(now())

  @@unique([tradeAnalyticsId, offsetSeconds])
}

// ── Persisted news articles ────────────────────────────────────────────────

model NewsArticle {
  id         Int    @id @default(autoincrement())
  ticker     String
  title      String @db.Text
  body       String @db.Text
  author     String
  source     String
  createdAt  String
  receivedAt String

  @@index([receivedAt])
  @@index([source])
}

// ── Strategy cache: persisted strategy recommendations ─────────────────────

model StrategyRule {
  id                String   @id @default(cuid())
  catalystCategory  String   // e.g. "FDA_APPROVAL"
  capBucket         String   @default("ALL") // NANO, MICRO, SMALL, MID, LARGE, ALL
  todBucket         String   @default("ALL") // PRE_MARKET, MARKET_OPEN, MID_DAY, POWER_HOUR, ALL

  holdDurationSec   Int      // recommended hold time in seconds
  trailingStopPct   Float    // recommended trailing stop %
  confidence        Float    // 0-1, based on sample size
  sampleSize        Int      // number of trades this is based on
  avgReturnPct      Float    // average return at recommended hold time
  medianReturnPct   Float    // median return at recommended hold time
  winRate           Float    // % of trades that were profitable

  computedAt        DateTime @default(now())

  @@unique([catalystCategory, capBucket, todBucket])
}

// ── Autonomous bot tables ──────────────────────────────────────────────────

// BotTrade — full lifecycle record for every trade the bot considers or executes
// status: "open" | "closed" | "missed"
// exitReason: "trailing_stop" | "hard_stop" | "profit_target" | "time_exit" | "force_close" | "reconciled_missing_on_startup"
model BotTrade {
  id             String    @id @default(cuid())
  symbol         String
  entryPrice     Float?
  exitPrice      Float?
  shares         Float?
  pnl            Float?
  catalystType   String?
  catalystTier   Int?
  exitReason     String?
  status         String
  alpacaOrderId  String?
  entryAt        DateTime?
  exitAt         DateTime?
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  @@index([status])
  @@index([symbol])
  @@index([createdAt])
}

// BotConfig — singleton row (id = "singleton"); all thresholds defined upfront
// state: "stopped" | "running" | "paused"
// mode: "paper" | "live"
// enabledCatalystTiers: comma-separated string e.g. "1,2,3,4"; parse with .split(",").map(Number)
model BotConfig {
  id                       String   @id @default("singleton")
  enabled                  Boolean  @default(false)
  state                    String   @default("stopped")
  mode                     String   @default("paper")
  positionSizeUsd          Float    @default(500)
  confidenceMultiplierHigh Float    @default(2.0)
  confidenceMultiplierMed  Float    @default(1.0)
  confidenceMultiplierLow  Float    @default(0.5)
  maxConcurrentPositions   Int      @default(3)
  dailyLossLimitUsd        Float    @default(500)
  minWinRate               Float    @default(0.5)
  hardStopLossPct          Float    @default(7.0)
  maxHoldDurationSec       Int      @default(300)
  enabledCatalystTiers     String   @default("1,2,3,4")
  maxFloatShares           Float    @default(20000000)
  maxSharePrice            Float    @default(20)
  minRelativeVolume        Float    @default(5)
  updatedAt                DateTime @updatedAt
}

// BotDailyStats — one row per trading day, keyed on date string ("YYYY-MM-DD" ET)
// Used by circuit breakers (dailyLossLimitUsd) and PDT guard (dayTradeCount)
model BotDailyStats {
  id            String   @id @default(cuid())
  date          String
  realizedPnl   Float    @default(0)
  tradeCount    Int      @default(0)
  dayTradeCount Int      @default(0)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@unique([date])
}
